/*
 * Copyright 2010 Christian Schindelhauer, Peter Thiemann, Faisal Aslam, Luminous Fennell and Gidon Ernst.
 * All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 * 
 * This code is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3
 * only, as published by the Free Software Foundation.
 * 
 * This code is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 3 for more details (a copy is
 * included in the LICENSE file that accompanied this code).
 * 
 * You should have received a copy of the GNU General Public License
 * version 3 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 * 
 * Please contact Faisal Aslam 
 * (aslam AT informatik.uni-freibug.de or studentresearcher AT gmail.com)
 * if you need additional information or have any questions.
 */
package takatuka.optimizer.bytecode.changer.logic;

import takatuka.classreader.dataObjs.attribute.*;
import takatuka.classreader.dataObjs.*;
import takatuka.classreader.logic.StartMeAbstract;
import takatuka.classreader.logic.constants.*;
import takatuka.classreader.logic.logAndStats.*;
import takatuka.optimizer.bytecode.branchSetter.dataObjs.attributes.*;
import takatuka.vm.autoGenerated.vmSwitch.*;
import takatuka.classreader.logic.util.*;
import takatuka.optimizer.bytecode.changer.logic.freq.*;

/**
 * 
 * Description:
 * <p>
 * 
 * It change the instructions so that they do not have waste of bytes in offset
 * or constant pool ids. For example: a instruction with less than 256 constant 
 * pool index will now have only one byte address instead of two bytes.
 * 
 * </p> 
 * @author Faisal Aslam
 * @version 1.0
 */
public class CPAndOffSetChangedInstructions {

    public static final int MAX_ONE_BYTE = 255;
    private static final CPAndOffSetChangedInstructions cpAndOffSetChange =
            new CPAndOffSetChangedInstructions();
    private static int totalSavings = 0;
    private static final String ADDITIONAL_MNEMONIC = "_SHORT";
    private boolean alreadyAllInstructionsUpdated = false;
    private static final String TOTAL_NUMBER_OF_CP_OFFSET_OPTIM_INST =
            "instructions_used_by_operand_reduction";
    private static final String TOTAL_SAVING_USING_CP_BYTECODE_OPTIM_INST =
            "total_savings_using_operand_reduction";
    private static final String REDUCTION_PERCENT_PER_INST = "reduction % per instruction";
    private RegisterCustomInstruction regCustInst = RegisterCustomInstruction.getInstanceOf();
    private static final StatsHolder statHolder = StatsHolder.getInstanceOf();
    private static final LogHolder logHolder = LogHolder.getInstanceOf();
    private int opcodeAvilAtstart = 0;
    private int numberofNewCombined = 0;
    private FreqMap freq = new FreqMap();

    public static CPAndOffSetChangedInstructions getInstanceOf() {
        return cpAndOffSetChange;
    }

    private void updateAllInstructions() {
        InstructionsController instCont = InstructionsController.getInstanceOf();
        Instruction inst = null;
        for (int index = 0; index < instCont.getCurrentSize(); index++) {
            inst = (Instruction) instCont.get(index);
            updateInstruction(inst);
        }
    }

    private class CPOffSetAllowedInstr implements AllowedInstructions {

        @Override
        public boolean allowed(Instruction inst) {
            int operand = CPAndOffSetChangedInstructions.getConstantPoolAddress(inst);
            if (operand == -1) {
                operand = CPAndOffSetChangedInstructions.getLocalOffsetTwoBytes(inst);
            }
            if (operand == -1) {
                operand = CPAndOffSetChangedInstructions.getCastMethodInstrStackAddress(inst);
            }
            if (operand == -1 || operand > 255) {
                return false;
            }
            return true;
        }
    }

    public static Instruction createVirtualInstrForCPAndOffSet(Instruction inst) {
        Un unOperand = (Un) inst.getOperandsData().clone();
        unOperand = unOperand.trim(1);
        String newMne = inst.getMnemonic() + "_Dummy";
        inst = (Instruction) inst.clone();
        inst.setMnemonic(newMne);
        inst.setOperandsData(unOperand);
        return inst;
    }

    public void execute() {
        if (alreadyAllInstructionsUpdated) {
            return;
        }
        //InstructionsController.getInstanceOf().reCacheInstructions();
        //FreqOfCPAndOffSetInstructions.getInstanceOf().createFreqRecord();
        //Miscellaneous.println("-----------> "+FreqOfCPAndOffSetInstructions.getInstanceOf().toString());

        regCustInst.startOrEndOfAnOptimization();
        opcodeAvilAtstart = regCustInst.numberOfOpCodesavailable();
        InstructionsController instCont = InstructionsController.getInstanceOf();

        /*Vector freq1 = FreqOperandsCombiner.findFreqsOfCombineOperandInst(instCont, freq,
        new CPOffSetAllowedInstr(), false);
         */
        //Miscellaneous.println("2 ******** See Me ********* " + InstructionsCombined.numberOfOpCodesavailable());
        updateAllInstructions();
        generateStats();
    }

    private void generateStats() {
        double reductionPerc = StartMeBCC.totalReductionPercentage(totalSavings);
        statHolder.addStat(StatGroups.OPERAND_REDUCTION_OPTIMIZATION,
                TOTAL_NUMBER_OF_CP_OFFSET_OPTIM_INST,
                totalCreatedNewInsturctions());
        statHolder.addStat(StatGroups.OPERAND_REDUCTION_OPTIMIZATION,
                "no_of_new_combinations", numberofNewCombined);
        statHolder.addStat(StatGroups.OPERAND_REDUCTION_OPTIMIZATION,
                TOTAL_SAVING_USING_CP_BYTECODE_OPTIM_INST,
                getTotalSavings());

        statHolder.addStat(StatGroups.OPERAND_REDUCTION_OPTIMIZATION,
                REDUCTION_PERCENT_PER_INST,
                StartMeAbstract.roundDouble(reductionPerc / (double) totalCreatedNewInsturctions(),2));

        statHolder.addStat(StatGroups.OPERAND_REDUCTION_OPTIMIZATION,
                "reduction %", 
                StartMeAbstract.roundDouble(reductionPerc, 2));
    }

    private boolean updateInstruction(Instruction instInput) {
        BHInstruction inst = (BHInstruction) instInput;
        if (regCustInst.numberOfOpCodesavailable() == 0
                || Instruction.getOpcode(inst.getMnemonic()) == -1) {
            return false;
        }
        //Miscellaneous.println("See me --------- "+perOccur+", "+inst.getMnemonic());
        if (!new CPOffSetAllowedInstr().allowed(instInput)) {
            return false;
        }
        if (!updateConstantPoolAddress(inst)) {
            if (!updateLocalOffsetAddress(inst)) {
                //if (!updateMethodCastInstruction(instInput)) {
                    return false;
                //}
            }
        }
        return true;
    }

    public int totalCreatedNewInsturctions() {
        regCustInst.startOrEndOfAnOptimization();
        return opcodeAvilAtstart - regCustInst.numberOfOpCodesavailable();
    }

    public int getTotalSavings() {
        return totalSavings;
    }

    private boolean updateMethodCastInstruction(Instruction instr) {
        boolean ret = false;
        try {
            int address = getCastMethodInstrStackAddress(instr);
            int opcode = instr.getOpCode();
            Un operand = (Un) instr.getOperandsData().clone();
            Un unAdd = null;
            if (address < MAX_ONE_BYTE && address >= 0) {
                operand = operand.trim(2);
                operand.conCat(new Un(address).trim(1));

            } else {
                return ret;
            }
            ret = true;
            changeInstruction(instr, operand);
        } catch (Exception d) {
            d.printStackTrace();
            Miscellaneous.exit();
        }
        return ret;
    }

    private boolean updateConstantPoolAddress(Instruction inst) {
        boolean ret = false;
        try {
            int address = getConstantPoolAddress(inst);
            int opCode = inst.getOpCode();
            Un unAdd = null;
            if (address < MAX_ONE_BYTE && address >= 0) {
                unAdd = new Un(address).trim(1);
            } else {
                return ret; // do not bother...
            }
            ret = true;
            if (opCode == JavaInstructionsOpcodes.MULTIANEWARRAY) {
                Un originalOperand = (Un) inst.getOperandsData().clone();
                //cut everything other than first two bytes
                Un.cutBytes(originalOperand.size() - 2, originalOperand);
                unAdd.conCat(originalOperand);
                //combine new byte with it.
            }
            changeInstruction(inst, unAdd);
        } catch (Exception d) {
            d.printStackTrace();
            Miscellaneous.exit();
        }
        return ret;
    }

    // call this function after optimization for bytecode. As that will decrease code size
    // and reduce address sizes.
    private boolean updateLocalOffsetAddress(Instruction inst) {
        boolean ret = false;
        //always ignore wide
        try {
            int address = getLocalOffsetTwoBytes(inst);
            Un unAdd = null;
            if (address < MAX_ONE_BYTE && address > 0) {
                unAdd = new Un(address).trim(1);
            } else {
                return ret; // do not bother...
            }
            ret = true;
            changeInstruction(inst, unAdd);
        } catch (Exception d) {
            d.printStackTrace();
            Miscellaneous.exit();
        }
        return ret;
    }

    private void changeInstruction(Instruction inst, Un changedOperand) {
        Instruction originalInstr = (Instruction) inst.clone();
        totalSavings++;
        inst.setOperandsData(changedOperand);
        //change opCode
        String mnemonic = inst.getMnemonic() + ADDITIONAL_MNEMONIC;
        inst.setMnemonic(mnemonic);
        if (regCustInst.register(inst, originalInstr)) {
            numberofNewCombined++;
        }
    }

    public int getNumberOfNewCombinations() {
        return numberofNewCombined;
    }

    /**
     * return operand if instruction is offset instruction of two bytes 
     * otherwise it returns -1
     * @param inst
     * @return
     */
    public static int getLocalOffsetTwoBytes(Instruction inst) {
        int ret = -1;
        if (inst.getOperandsData().size() == 0) {
            return -1;
        }

        int opCode = inst.getOpCode();
        Un operand = null;
        try {
            operand = (Un) inst.getOperandsData().clone();
            if ((opCode >= JavaInstructionsOpcodes.IFEQ
                    && opCode <= JavaInstructionsOpcodes.JSR)
                    || opCode == JavaInstructionsOpcodes.IFNONNULL
                    || opCode == JavaInstructionsOpcodes.IFNULL) {
                ret = Un.cutBytes(2, operand).intValueUnsigned();
            }
        } catch (Exception d) {
            Miscellaneous.printlnErr(" +++++++++++++ opcode = " + opCode
                    + ", " + operand + ", " + operand.size());
            d.printStackTrace();
            Miscellaneous.exit();
        }
        return ret;
    }

    private static int getLocalOffsetFourBytes(Instruction inst) {
        int ret = -1;
        try {
            int opCode = inst.getOpCode();
            Un operand = (Un) inst.getOperandsData().clone();
            if (opCode == JavaInstructionsOpcodes.JSR_W
                    || opCode == JavaInstructionsOpcodes.GOTO_W) {
                ret = Un.cutBytes(2, operand).intValueUnsigned();
            }
        } catch (Exception d) {
            d.printStackTrace();
            Miscellaneous.exit();
        }
        return ret;
    }

    public static int getCastMethodInstrStackAddress(Instruction instr) {
        int ret = -1;
        try {
            if (instr.getOpCode() == JavaInstructionsOpcodes.CAST_METHOD_STACK_LOCATION) {
                int sizeOfStackLocOperand = BytecodeProcessor.getAllParameterSizes(JavaInstructionsOpcodes.CAST_METHOD_STACK_LOCATION).lastElement();
                Un operand = (Un) instr.getOperandsData().clone();
                Un.cutBytes(operand.size() - sizeOfStackLocOperand, operand);
                ret = operand.intValueUnsigned();
            }
        } catch (Exception d) {
            d.printStackTrace();
            Miscellaneous.exit();
        }
        return ret;
    }

    /**
     * return cp address if instruction was a CP-instruction otherwise
     * return -1
     * 
     * @param inst
     * @return
     */
    public static int getConstantPoolAddress(Instruction inst) {
        int ret = -1;
        if (inst.getOperandsData().size() == 0) {
            return -1;
        }
        int opCode = inst.getOpCode();
        try {
            Un operand = (Un) inst.getOperandsData().clone();
            if (opCode == JavaInstructionsOpcodes.ANEWARRAY
                    || opCode == JavaInstructionsOpcodes.CHECKCAST
                    || opCode == JavaInstructionsOpcodes.GETFIELD
                    || opCode == JavaInstructionsOpcodes.GETSTATIC
                    || opCode == JavaInstructionsOpcodes.INSTANCEOF
                    || opCode == JavaInstructionsOpcodes.INVOKEINTERFACE
                    || opCode == JavaInstructionsOpcodes.INVOKESPECIAL
                    || opCode == JavaInstructionsOpcodes.INVOKESTATIC
                    || opCode == JavaInstructionsOpcodes.INVOKEVIRTUAL
                    || opCode == JavaInstructionsOpcodes.LDC_W
                    || opCode == JavaInstructionsOpcodes.LDC2_W
                    || opCode == JavaInstructionsOpcodes.LDC2_W_LONG
                    || opCode == JavaInstructionsOpcodes.LDC_W_FLOAT
                    || opCode == JavaInstructionsOpcodes.LDC_W_INT
                    || opCode == JavaInstructionsOpcodes.MULTIANEWARRAY
                    || opCode == JavaInstructionsOpcodes.NEW
                    || opCode == JavaInstructionsOpcodes.PUTFIELD
                    || opCode == JavaInstructionsOpcodes.PUTSTATIC) {
                //Miscellaneous.println("here here ="+inst.getMnemonic());
                ret = Un.cutBytes(2, operand).intValueUnsigned();
            }
        } catch (Exception d) {
            Miscellaneous.printlnErr("operand= " + inst.getOperandsData()
                    + ", size=" + inst.getOperandsData().size()
                    + ", Mnemonic" + inst.getMnemonic());
            d.printStackTrace();
            Miscellaneous.exit();
        }
        return ret;
    }
}
