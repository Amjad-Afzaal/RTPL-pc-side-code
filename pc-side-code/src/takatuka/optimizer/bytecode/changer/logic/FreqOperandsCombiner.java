/*
 * Copyright 2010 Christian Schindelhauer, Peter Thiemann, Faisal Aslam, Luminous Fennell and Gidon Ernst.
 * All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 * 
 * This code is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3
 * only, as published by the Free Software Foundation.
 * 
 * This code is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 3 for more details (a copy is
 * included in the LICENSE file that accompanied this code).
 * 
 * You should have received a copy of the GNU General Public License
 * version 3 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 * 
 * Please contact Faisal Aslam 
 * (aslam AT informatik.uni-freibug.de or studentresearcher AT gmail.com)
 * if you need additional information or have any questions.
 */
package takatuka.optimizer.bytecode.changer.logic;

import takatuka.classreader.dataObjs.attribute.*;
import takatuka.optimizer.bytecode.changer.logic.comb.*;
import takatuka.optimizer.bytecode.changer.logic.freq.*;
import java.util.*;
import takatuka.classreader.logic.util.*;
import takatuka.classreader.dataObjs.*;
import takatuka.classreader.logic.StartMeAbstract;
import takatuka.classreader.logic.constants.*;
import takatuka.classreader.logic.logAndStats.LogHolder;
import takatuka.classreader.logic.logAndStats.StatsHolder;
import takatuka.optimizer.cpGlobalization.logic.util.Oracle;
import takatuka.vm.autoGenerated.vmSwitch.*;

/**
 * 
 * Description:
 * <p>
 *  In case a instruction with same operand appears multiple times then it combines it.
 * 
 * Step 1: find freq of instructions by combining their operands
 * Step 2: Sort them in terms of totalSavings = savings*freq.
 * Step 3: while (remove top instructions and save it) until totalSavings > 2% of the total code size
 * Step 4: Now replace the saved instruction (of step 3) in the code
 * 
 * </p> 
 * @author Faisal Aslam
 * @version 1.0
 */
public class FreqOperandsCombiner {

    private static final FreqOperandsCombiner fOComb = new FreqOperandsCombiner();
    private InstructionsController instCont = null;
    private double percentageThreshold = -1;
    private FreqMap freq = new FreqMap();
    private int instAvailableAtStart = 0;
    private long totalSavings = 0;
    private HashMap maxSavings = new HashMap();
    private static final LogHolder logHolder = LogHolder.getInstanceOf();
    private RegisterCustomInstruction regCustInstr = RegisterCustomInstruction.getInstanceOf();
    private static final StatsHolder statHolder = StatsHolder.getInstanceOf();
    private static int numberofNewCombined = 0;

    private FreqOperandsCombiner() {
    }

    public static FreqOperandsCombiner getInstanceOf() {
        return fOComb;
    }

    private class OperandCombinerAllowedInstruction implements AllowedInstructions {

        public boolean allowed(Instruction inst) {
            if (inst.getMnemonic().contains("SWITCH")
                    || inst.getMnemonic().contains("WIDE")
                    || inst.getOperandsData().size() == 0
                    || inst.isBranchSourceInstruction()) {
                return false;
            }
            return true;
        }
    }
    //Step 1: find freq of instructions by combining their operands
    // Step 2: Sort them in terms of totalSavings = savings*freq.

    static Vector findFreqsOfCombineOperandInst(InstructionsController instCont,
            FreqMap freq, AllowedInstructions allowedInstr, boolean isOperandCombination) {
        try {
            Instruction inst = null;
            InstructionsCombined comb = null;
            InstructionFrequency instFreq = InstructionFrequency.getInstanceOf();
            instFreq.clear();
            int size = instCont.getCurrentSize();
            for (int index = 0; index < size; index++) {
                inst = (Instruction) instCont.get(index);
                if (!allowedInstr.allowed(inst)) {
                    continue;
                }
                Vector originalInstrs = new Vector();

                originalInstrs.addElement(inst.clone());
                if (isOperandCombination) {
                    comb = InstructionsCombined.createInstructionWithOperandsCombined(inst);
                } else {
                    comb = InstructionsCombined.createImaginaryInstrctionWithOperandReduction(inst);
                }
                if (comb != null) {
                    if (freq.getValue(comb) == null) {
                        freq.put(comb, -1, originalInstrs);
                    } else {
                        freq.inc(comb, -1);
                    }
                }
            }
        } catch (Exception d) {
            d.printStackTrace();
            Miscellaneous.exit();
        }
        return getHighestFreqMulSavingCombinationsKeys(freq);
    }

    private static Vector getHighestFreqMulSavingCombinationsKeys(FreqMap freq) {
        Vector freqKeys = freq.getAllKeys();
        QuickSort.sort(freqKeys, new FreqMapValueComparator(freq));
        return freqKeys;
    }

    private boolean tooManyOpcodes(int currentSelected) {
        //Miscellaneous.println("---------> " + ((regCustInstr.numberOfOpCodesavailable() - currentSelected) > 70));
        boolean ret = (regCustInstr.numberOfOpCodesavailable() - currentSelected) > 60;
        return ret;
    }

    //Step 3: while (remove top instructions and save it) until totalSavings > x% of the total code size
    private Vector selectTopInstructions(Vector highestKeys) {
        FreqMapValue value = null;
        String key = null;
        double totalSavLocal = 0;
        int totalInstSize = instCont.getSizeOfInstructions();
        double minSavingRequired = ((double) totalInstSize) * (percentageThreshold / 100);
        int currentSelected = 0;
        /*Miscellaneous.println("total Size ="+totalInstSize+
        ", valid instructions should have savings more than "+
        minSavingRequired);*/
        Vector ret = new Vector();
        //if (true) return ret;
        for (int index = 0; index < highestKeys.size(); index++) {
            key = (String) highestKeys.elementAt(index);
            value = freq.getValue(key);
            totalSavLocal = (value.freq * value.instComb.getSavings())
                    + BCCompactionCost.getInstanceOf().getTotalReduction(value);

            //Miscellaneous.println(value + "......."+totalSavLocal);
            
            /**
             * following is used only in full compaction
             */
            if (InputOptionsController.isIgnoreJVMSwitchInc) {
                if (tooManyOpcodes(currentSelected++)) {
                    ret.addElement(value);
                } else {
                    break;
                }
            } else if (totalSavLocal >= minSavingRequired) {
                ret.addElement(value);
            } else {
                //Miscellaneous.println("adfafasd "+value.instComb.getSavings());
                //Miscellaneous.println("stop here"+BCCompactionCost.getInstanceOf().getTotalReduction(value));
                break;
            }
        }
        return ret;
    }

    //Step 4: Now replace the saved instruction (of step 3) in the code
    private void updateInstruction(Vector<FreqMapValue> topSelectedComb) {
        InstructionsCombined comb = null;
        Instruction inst = null;
        for (int index = 0; index < topSelectedComb.size()
                && regCustInstr.numberOfOpCodesavailable() > 0; index++) {
            FreqMapValue value = topSelectedComb.get(index);
            comb = value.instComb;
            inst = value.originalInstructions.elementAt(0);
            if (inst.getOperandsData().size() != 0) {
                updateHelper((Instruction) inst.clone(), comb);
            }

            //Miscellaneous.println("-------- "+InstructionsController.getInstanceOf());
        }
    }

    // search original instruction in the code and replace whereever it occurs.
    private void updateHelper(Instruction originalInst, InstructionsCombined comb) {
        InstructionsController cont = InstructionsController.getInstanceOf();
        try {
            for (int loop = 0; loop < cont.getCurrentSize(); loop++) {
                Instruction inst = (Instruction) cont.get(loop);
                //Miscellaneous.println(" SEE ME "+inst.getMnemonic()+ ", "+inst.getOperandsData());
                if (inst.equals(originalInst)) {
                    inst.setMnemonic(comb.getMnemonic());
                    inst.setOperandsData(new Un());
                    if (regCustInstr.register(inst, originalInst)) {
                        numberofNewCombined++;
                    }
                }
            }
        } catch (Exception d) {
            d.printStackTrace();
            Miscellaneous.exit();
        }
    }

    public int getNumberOfNewCombinations() {
        return numberofNewCombined;
    }

    /* public int getMaxSavings() {
    Vector keys = new Vector(maxSavings.keySet());
    int max = 0;
    String bestKey = null;
    for (int index = 0; index < keys.size(); index++) {
    Object key = keys.elementAt(index);
    int savings = (Integer) maxSavings.get(key);
    if (savings > max) {
    max = savings;
    bestKey = (String) key;
    }
    }
    return max;
    }*/
    public int numberOpcodeUsed() {
        regCustInstr.startOrEndOfAnOptimization();
        return instAvailableAtStart - regCustInstr.numberOfOpCodesavailable();
    }

    public void execute(double percentageThreshold) {
        BCCompactionCost.getInstanceOf().clearAlreadyConsiderSwitchDecInstRecord();
        totalSavings = Oracle.getInstanceOf().getCurrentTotalCodeLength();
        this.percentageThreshold = percentageThreshold;
        statHolder.addStat(StatGroups.OPCODE_OPERAND_COMBINATION_OPTIMIZATION, "% threshold",
                this.percentageThreshold);

        instCont = InstructionsController.getInstanceOf();
        instCont.reCacheInstructions();
        this.instAvailableAtStart = regCustInstr.numberOfOpCodesavailable();
        //Miscellaneous.println("1 ******** See Me ********* " + InstructionsCombined.numberOfOpCodesavailable());
        Vector freq1 = findFreqsOfCombineOperandInst(instCont, freq,
                new OperandCombinerAllowedInstruction(), true);
        //Miscellaneous.println("2 ******** See Me ********* " + InstructionsCombined.numberOfOpCodesavailable());
        Vector topInst = selectTopInstructions(freq1);
        //Miscellaneous.println("3 ******** See Me ********* " + InstructionsCombined.numberOfOpCodesavailable());

        updateInstruction(topInst);
        generateStats();
        BCCompactionCost.getInstanceOf().clearAlreadyConsiderSwitchDecInstRecord();
        //Miscellaneous.println("5 ******** See Me ********* " + InstructionsCombined.numberOfOpCodesavailable());
    }

    private void generateStats() {
        totalSavings = totalSavings - Oracle.getInstanceOf().getCurrentTotalCodeLength();
        double reductionPer = StartMeBCC.totalReductionPercentage(totalSavings);
        statHolder.addStat(StatGroups.OPCODE_OPERAND_COMBINATION_OPTIMIZATION,
                "number_of_opcode_used", numberOpcodeUsed());
        statHolder.addStat(StatGroups.OPCODE_OPERAND_COMBINATION_OPTIMIZATION,
                "no_of_new_combinations", numberofNewCombined);
        statHolder.addStat(StatGroups.OPCODE_OPERAND_COMBINATION_OPTIMIZATION,
                "total_savings", totalSavings);
        statHolder.addStat(StatGroups.OPCODE_OPERAND_COMBINATION_OPTIMIZATION,
                "reduction %", 
                StartMeAbstract.roundDouble(reductionPer, 2));
        statHolder.addStat(StatGroups.OPCODE_OPERAND_COMBINATION_OPTIMIZATION,
                "reduction % per instruction", 
                StartMeAbstract.roundDouble(reductionPer / numberOpcodeUsed(),2));

        logHolder.addLog("Combined operand and opcode of "
                + numberOpcodeUsed() + " instructions and "
                + "achieved saving of " + totalSavings + "....");
    }
}
