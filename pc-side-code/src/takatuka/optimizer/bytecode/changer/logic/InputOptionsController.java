/*
 * Copyright 2010 Christian Schindelhauer, Peter Thiemann, Faisal Aslam, Luminous Fennell and Gidon Ernst.
 * All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 * 
 * This code is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3
 * only, as published by the Free Software Foundation.
 * 
 * This code is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 3 for more details (a copy is
 * included in the LICENSE file that accompanied this code).
 * 
 * You should have received a copy of the GNU General Public License
 * version 3 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 * 
 * Please contact Faisal Aslam 
 * (aslam AT informatik.uni-freibug.de or studentresearcher AT gmail.com)
 * if you need additional information or have any questions.
 */
package takatuka.optimizer.bytecode.changer.logic;

import java.util.StringTokenizer;
import takatuka.optimizer.VSS.logic.preCodeTravers.*;
import takatuka.tukFormat.*;
import takatuka.tukFormat.logic.*;
import takatuka.optimizer.bytecode.changer.logic.freq.*;
import takatuka.optimizer.bytecode.changer.logic.comb.*;
import takatuka.optimizer.bytecode.changer.logic.freq.stephan.*;
import takatuka.optimizer.bytecode.replacer.logic.*;
import takatuka.optimizer.cpGlobalization.logic.util.*;
import takatuka.optimizer.deadCodeRemoval.logic.*;
import takatuka.classreader.dataObjs.attribute.*;
import takatuka.classreader.logic.*;
import takatuka.classreader.logic.file.*;
import takatuka.classreader.logic.logAndStats.*;
import takatuka.classreader.logic.constants.*;
import takatuka.classreader.logic.util.*;
import takatuka.offlineGC.generateInstrs.*;
import takatuka.vm.autoGenerated.vmSwitch.*;
import takatuka.offlineGC.logic.*;
import takatuka.optimizer.bytecode.branchSetter.logic.*;
import takatuka.verifier.logic.*;
import takatuka.chunkSizeCalc.GenerateCVCSInfo;
import takatuka.offlineGC.OGI.DAGUtils.GraphLabelsController;
import takatuka.tukFormat.verifier.logic.TukFileVerifier;
import takatuka.vm.autoGenerated.JVMConfiguration;

/**
 * 
 * Description:
 * <p>
 * It has most of the logic for BCC (bytecode compcation). 
 * It calls other classes
 * </p> 
 * @author Faisal Aslam
 * @version 1.0
 */
public class InputOptionsController {

    private final static InputOptionsController engine = new InputOptionsController();
    private final static LogHolder logHolder = LogHolder.getInstanceOf();
    private final static StatsHolder statHolder = StatsHolder.getInstanceOf();
    private static boolean isStephenAlgo = true;
    public static boolean executeCPAndOffsetOptimization = true;
    private static boolean readCombinationsFromFile = false;
    private static final String readCombFileName = "combinationFile.txt";
    private int lastUsedOpcodesSize = 0;
    private int instructionUseInMultipleCombination = 0;
    private static boolean noMultCombination = false;
    private static boolean noOperandOpCodeCombination = false;
    private double percentThresholdOPPlusOP = 0.0;
    private final static String OPTION_HELP = "-help";
    private final static String OPTION_MAXINPUT = "-maxinput";
    private final static String OPTION_ALGO = "-algo";
    private final static String OPTION_NOC = "-noc";
    private final static String OPTION_SCO = "-sco";
    private final static String OPTION_osize = "-osize";
    private final static String OPTION_RFILE = "-rfile";
    private final static String OPTION_PERCENTAGE_OP_OP = "-p";
    private final static String OPTION_NO_MULTI_COMBINATION = "-no";
    private final static String OPTION_NO_OPERAND_OPCODE_COM = "-n";
    private final static String OPTION_NO_BYTECODE_OPTIMIZATION = "-nooptim";
    private final static String OPTION_ALWAYS_BIG_METHODS = "-bigMethods";
    private final static String OPTION_ALWAYS_BIG_ADDRESSES = "-bigAddresses";
    private final static String OPTION_UNKNOWN = "unrecognized parameter";
    private final static String OPTION_CONFIG_ADDRESS = "-propAdd";
    private final static String OPTION_MAIN_CLASS_NAME = "-main";
    private final static String OPTION_NOMAIN_CLASS = "-nomain";
    private final static String OPTION_CVCS = "-cvcs";
    private final static String OPTION_FULL_COMPACTION = "-FC";
    private final static String OPTION_USE_OFFLINE_GC = "-offLineGC";
    private final static String OPTION_USE_OFFLINE_GC_GRAPHS = "-OGCGraphs";
    private final static String OPTION_IGNORE_JVMSWITCH_INC = "-igswitchcost";
    private final static String OPTION_NO_DEAD_CODE_REMOVAL = "-noDeadCodeRmv";
    private final static String OPTION_LV_STACK_OPTIM = "-LVAndStackOptim";
    private final static String OPTION_SLOT_SIZE_FOR_VSS = "-vssSlotSize";
    private final static String OPTION_NO_CLASS_FILE_VERIFICATION = "-noVerify";
    private final static String OPTION_NO_VERBOSE = "-noVerbose";
    private final static String OPTION_REMOVE_DANGLING_REFE = "-removeDR";
    private final static String OPTION_GENERAL_PURPOSE_JVM = "-GPJVM";
    private final static String OPTION_OFFLINE_GC_MAX_NEW_ID_GENERATED = "-setManuallyMaxNewIdGenerated";
    private final static String OPTION_VALID_NEWID_LIST_FOR_OFFLINEGC = "-offLineValidNewIdList";
    private final static String OPTION_ALLOWED_SINGLE_ID_FOR_OFFLINEGC = "-offLineGCSingleID";
    private final static String OPTION_ALLOWED_END_RANGE_FOR_OFFLINEGC = "-offLineGCIDEndRange";
    private final static String OPTION_ALLOWED_START_RANGE_FOR_OFFLINEGC = "-offLineGCIDStartRange";
    private final static String OPTION_OFFLINE_GC_ALGORITHM_SELECTOR = "-offLineAlgoSelector";
    private final static String OPTION_GENERATE_SWITCH = "-genSwitch";
    private final static String OPTION_INSERT_FREEMEMORY_INSTR_FOR_OGC_RESULTS = "-insertOffGCResultInstr";
    private final static String OPTION_KEEP_ID_WITH_MAX_SIZE_OFFLLINE_GC = "-offLineIDsWithMaxSizedObjs";
    private final static String OPTION_CVCS_FILE = "-cvcsFile";
    private final static String OPTION_VERIFY_TUK_FILE = "-verifyTuk";
    public static boolean isIgnoreJVMSwitchInc = false;
    private boolean isNoMain = false;
    private Oracle oracle = Oracle.getInstanceOf();
    public static final int OPTIM_NOT_STARTED = 0;
    public static final int OPTIM_STARTED_BUT_NOTHING_IS_FINISH = 1;
    public static final int OPERAND_COMBINATION_IS_DONE = 2;
    public static final int OPERAND_REDUCTION_IS_DONE = 3;
    public static final int MIC_IS_DONE = 4;
    public static final int OPTIM_IS_ENDED = 5;
    private static int currentStateOfOptimiation = 0;
    private static boolean wantedAGPJVM = false;
    private static long codeLengthAtTheStartOfOptim = 0;

    private InputOptionsController() {
        //no one creates me but me
    }

    public static InputOptionsController getInstanceOf() {
        return engine;
    }

    /**
     * 
     * @return : returns OPTIM_NOT_STARTED if optimization is not yet started.
     * return OPTIM_STARTED_BUT_NOTHING_IS_FINISH if bytecode optimization is just started.
     * returns OPERAND_COMBINATION_IS_DONE if operand-combination is done.
     * returns OPERAND_REDUCTION_IS_DONE if operand-reduction is done.
     * returns MIC_IS_DONE if MIC is done 
     * return OPTIM_IS_ENDED if all optimization so done. Note it is same as saying MIC is done 
     * as it comes at the last.
     */
    public static int getCurrentStateOfOptimization() {
        return currentStateOfOptimiation;
    }

    private static void setCurrentStateOfOptimization(int state) {
        currentStateOfOptimiation = state;
    }

    public static boolean isGPJVMWanted() {
        return wantedAGPJVM;
    }

    void setDefaults() {
        readCombinationsFromFile = false;
        executeCPAndOffsetOptimization = true;
        InstructionFrequency.countCombinationAsSingle = false;
        InstructionFrequency.numberOfInstructionCombined = 4;
        isStephenAlgo = true;
        noMultCombination = false;
        noOperandOpCodeCombination = false;
    }

    String[] processArgs(String args[]) throws Exception {
        String superArgs[] = new String[args.length];

        superArgs[0] = args[0];
        superArgs[1] = args[1];
        if (args.length >= 3) {
            superArgs[2] = "-1";
        }
        int argLength = args.length;
        for (int currentPointer = 2; currentPointer < argLength; currentPointer++) {
            String currentOption = args[currentPointer].trim();
            //System.out.print("------- "+currentOption);
            if (currentOption.equals(OPTION_HELP)) {
                inputMessage();
                Miscellaneous.exit();
            } else if (currentOption.equals(OPTION_ALWAYS_BIG_METHODS)) {
                StartMeLF.setAlwaysBigMethods();
            } else if (currentOption.equals(OPTION_ALWAYS_BIG_ADDRESSES)) {
                LFEngine.setAlwaysBigAddresses();
            } else if (currentOption.equals(OPTION_MAIN_CLASS_NAME)) {
                currentPointer++;
                if (!isNoMain) {
                    StartMeDCR.setMainClassName(args[currentPointer]);
                }
            } else if (currentOption.equals(OPTION_IGNORE_JVMSWITCH_INC)) {
                isIgnoreJVMSwitchInc = true;
            } else if (currentOption.equals(OPTION_NO_DEAD_CODE_REMOVAL)) {
                StartMeDCR.setShouldWork(false);
            } else if (currentOption.equals(OPTION_REMOVE_DANGLING_REFE)) {
                LFEngine.removeDaglingReferences = true;
            } else if (currentOption.equals(OPTION_LV_STACK_OPTIM)) {
                StartMeVerifier.shouldVerify = true;
                ReduceTheSizeOfLocalVariables.doNotOptim = false;
            } else if (currentOption.equals(OPTION_SLOT_SIZE_FOR_VSS)
                    || currentOption.equals("-bsizeForLV")) {
                currentPointer++;
                ReduceTheSizeOfLocalVariables.BLOCK_SIZE_IN_BYTES = Integer.parseInt(args[currentPointer]);
                if (ReduceTheSizeOfLocalVariables.BLOCK_SIZE_IN_BYTES < 4 ||
                        currentOption.equals(OPTION_SLOT_SIZE_FOR_VSS)) {
                    StartMeVerifier.shouldVerify = true;
                    ReduceTheSizeOfLocalVariables.doNotOptim = false;
                }
            } else if (currentOption.equals(OPTION_NO_CLASS_FILE_VERIFICATION)) {
                StartMeVerifier.shouldVerify = false;
            } else if (currentOption.equals(OPTION_NO_VERBOSE)) {
                LogHolder.verboseAllowed = false;
            } else if (currentOption.equals(OPTION_USE_OFFLINE_GC)) {
                StartMeOGC.useOffLineGC = true;
                StartMeVerifier.shouldVerify = true;
                ReduceTheSizeOfLocalVariables.doNotOptim = false;
            } else if (currentOption.equals(OPTION_USE_OFFLINE_GC_GRAPHS)) {
                GraphLabelsController.printGraphInFile = true;
            } else if (currentOption.equals(OPTION_NOMAIN_CLASS)) {
                StartMeDCR.setMainClassName(null);
                isNoMain = true;
            } else if (currentOption.equals(OPTION_CVCS)) {
                StartMeOGC.useOGDFA = true;
                GenerateCVCSInfo.generateCVCSInfo = true;
                StartMeVerifier.shouldVerify = true;
                ReduceTheSizeOfLocalVariables.doNotOptim = false;
                currentPointer++;
                GenerateCVCSInfo.depthForCVCS = Integer.parseInt(args[currentPointer]);
                currentPointer++;
                GenerateCVCSInfo.maxChunkSize = Integer.parseInt(args[currentPointer]);
                currentPointer++;
                GenerateCVCSInfo.CHANGE_DEPTH = Double.parseDouble(args[currentPointer]);
            } else if (currentOption.equals(OPTION_CVCS_FILE)) {
                currentPointer++;
                GenerateCVCSInfo.cvcsInputFileName = args[currentPointer];
            } else if (currentOption.equals(OPTION_FULL_COMPACTION)) {
                isIgnoreJVMSwitchInc = true;
                InstructionFrequency.numberOfInstructionCombined = 100;
            } else if (currentOption.equals(OPTION_CONFIG_ADDRESS)) {
                PropertyReader.setPropertiesPath(args[++currentPointer]);
            } else if (currentOption.equals(OPTION_NO_BYTECODE_OPTIMIZATION)) {
                StartMeBCC.doOptimization = false;
            } else if (currentOption.equals(OPTION_NO_OPERAND_OPCODE_COM)) {
                noOperandOpCodeCombination = true;
            } else if (currentOption.equals(OPTION_MAXINPUT)) {
                currentPointer++;
                //just to validate it
                int maxInput = Integer.parseInt(args[currentPointer]);
                superArgs[2] = maxInput + "";
            } else if (currentOption.equals(OPTION_PERCENTAGE_OP_OP)) {
                currentPointer++;
                this.percentThresholdOPPlusOP = Double.parseDouble(args[currentPointer]);
            } else if (currentOption.equals(OPTION_NO_MULTI_COMBINATION)) {
                noMultCombination = true;
            } else if (currentOption.equals(OPTION_ALGO)) {
                currentPointer++;
                //just to validate it
                if (currentOption.equals("s")) {
                    isStephenAlgo = true;
                } else if (currentOption.equals("o")) {
                    isStephenAlgo = false;
                } else {
                    throw new Exception("invalid algroithm with option "
                            + OPTION_ALGO + ", use s or o");
                }
            } else if (currentOption.equals(OPTION_NOC)) {
                currentPointer++;
                InstructionFrequency.numberOfInstructionCombined =
                        Integer.parseInt(args[currentPointer]);
            } else if (currentOption.equals(OPTION_SCO)) {
                InstructionFrequency.countCombinationAsSingle = true;
            } else if (currentOption.equals(OPTION_osize)) {
                executeCPAndOffsetOptimization = false;
            } else if (currentOption.equals(OPTION_RFILE)) {
                currentPointer++;
                readCombinationsFromFile = Boolean.parseBoolean(args[currentPointer]);
            } else if (currentOption.equals(OPTION_GENERAL_PURPOSE_JVM)) {
                StartMeBCC.doOptimization = false;
                wantedAGPJVM = true;
            } else if (currentOption.equals(OPTION_ALLOWED_SINGLE_ID_FOR_OFFLINEGC)) {
                currentPointer++;
                int singleIdAllowed = Integer.parseInt(args[currentPointer]);
                GenerateInstrsForOfflineGC.setNewIdStartRange(singleIdAllowed);
                GenerateInstrsForOfflineGC.setNewIdEndRange(singleIdAllowed);
            } else if (currentOption.equals(OPTION_ALLOWED_END_RANGE_FOR_OFFLINEGC)) {
                currentPointer++;
                GenerateInstrsForOfflineGC.setNewIdEndRange(Integer.parseInt(args[currentPointer]));
            } else if (currentOption.equals(OPTION_VALID_NEWID_LIST_FOR_OFFLINEGC)) {
                currentPointer++;
                GenerateInstrsForOfflineGC.setValidNewIdsList(args[currentPointer]);
            } else if (currentOption.equals(OPTION_ALLOWED_START_RANGE_FOR_OFFLINEGC)) {
                currentPointer++;
                GenerateInstrsForOfflineGC.setNewIdStartRange(Integer.parseInt(args[currentPointer]));
            } else if (currentOption.equals(OPTION_OFFLINE_GC_ALGORITHM_SELECTOR)) {
                currentPointer++;
                StringTokenizer token = new StringTokenizer(args[currentPointer], ",");
                while (token.hasMoreTokens()) {
                    StartMeOGC.setGCAlgorithmSelector(Integer.parseInt(token.nextToken().trim()));
                }
            } else if (currentOption.equals(OPTION_OFFLINE_GC_MAX_NEW_ID_GENERATED)) {
                currentPointer++;
                JVMConfiguration.maxNewIdGenerated = Integer.parseInt(args[currentPointer]);
            } else if (currentOption.equals(OPTION_KEEP_ID_WITH_MAX_SIZE_OFFLLINE_GC)) {
                currentPointer++;
                GenerateInstrsForOfflineGC.setMaxSizeObjectsLimit(Integer.parseInt(args[currentPointer]));
            } else if (currentOption.equals(OPTION_GENERATE_SWITCH)) {
                StartMeLF.generateSwitchNotLables = true;
            } else if (currentOption.equals(OPTION_INSERT_FREEMEMORY_INSTR_FOR_OGC_RESULTS)) {
                StartMeOGC.insertFreeMemoryInstrForOffLineGCResults = true;
                currentPointer++;
                GenerateInstrForResults.insertInstrAfter = Integer.parseInt(args[currentPointer]);
                currentPointer++;
                if (!args[currentPointer].contains("-")) {
                    GenerateInstrForResults.functionAllowed = args[currentPointer];
                }
            } else if (currentOption.equals(OPTION_VERIFY_TUK_FILE)) {
                TukFileVerifier.shouldVerifyTukFile = true;
            } else {
                Miscellaneous.printlnErr(OPTION_UNKNOWN + " " + args[currentPointer]);
                throw new Exception(OPTION_UNKNOWN + " " + args[currentPointer]);
            }
        }
        return superArgs;
    }

    void inputMessage() {
        Miscellaneous.println(
                "Usage: StartMeLF <0:multiple-input file-name/directory-Name seperated by colon>"
                + " <1:output directory-Name>"
                + " -option(s) [help main nomain nooptim maxinput p no algo noc sco osize n"
                + " nor rfile bigMethods bigAddresses propAdd igswitchcost offLineGC]\n"
                + "options could come in any order but should come AFTER two mandatory parameters.\n\n"
                + "\t" + OPTION_HELP + ": shows this message \n"
                + "\t" + OPTION_MAIN_CLASS_NAME + " <class-name>: fully qualified name of the main class.\n"
                + "\t\t for Example: System.Collections.Queue or System/Collection/Queue \n"
                + "\t\t the default value is \"Main\"\n"
                + "\t" + OPTION_NOMAIN_CLASS + ": do not look for a main class \n"
                + "\t" + OPTION_NO_BYTECODE_OPTIMIZATION + ": do not do any bytecode optimizations \n"
                + "\t" + OPTION_MAXINPUT + " <#>: The number of files to read from input directory.\n"
                + "\t By default all files are read.\n"
                + "\t" + OPTION_PERCENTAGE_OP_OP + " <#>: Percentage threshold for operand+opcode combinations. (0.05% is default)\n"
                + "\t" + OPTION_NO_MULTI_COMBINATION + ": no multi instruction combination optimization.\n"
                + "\t" + OPTION_ALGO + " <s|o>: s stands for stephen and o stands for one \n"
                + "\t iteration algorithm\n"
                + "\t" + OPTION_NOC + " <#>: tells the max number of instructions to be combined.\n"
                + "\t-sco: (Deprecated) tells to take combination length as one\n"
                + "\t instead of number of instruction in it.\n"
                + "\t This option should no more supported\n"
                + "\t" + OPTION_osize + ": do not reduce operands size of (CP and offset) instructions\n"
                + "\t" + OPTION_NO_OPERAND_OPCODE_COM + ": do not combine operand opcodes\n"
                + "\t" + OPTION_RFILE + " <name>: reads combinations from file and do\n"
                + "\t optimization based on them.\n"
                + "\t" + OPTION_ALWAYS_BIG_METHODS + ": always have big methods .\n"
                + "\t" + OPTION_ALWAYS_BIG_ADDRESSES + ": always have 4 byte addresses in TUK .\n"
                + "\t" + OPTION_CONFIG_ADDRESS + ": specifiy a path to read properties \n"
                + "\t" + OPTION_IGNORE_JVMSWITCH_INC + ": ignore JVM switch increment while doing bytecode optimization \n"
                + "\t" + OPTION_USE_OFFLINE_GC + ": use offline GC on this application \n"
                + "\t" + OPTION_USE_OFFLINE_GC_GRAPHS + ": print offline GC graphs in dot files for debugging \n"
                + "\t" + OPTION_VALID_NEWID_LIST_FOR_OFFLINEGC + " <comma seperated numbers>: list of valid comma seperated new Ids  \n"
                + "\t" + OPTION_ALLOWED_SINGLE_ID_FOR_OFFLINEGC + " <number>: specify what single offLineGC free instruction id is allowed (useful for debugging). \n"
                + "\t" + OPTION_ALLOWED_END_RANGE_FOR_OFFLINEGC + " <number>: specify what offLineGC free instruction id end range is allowed (useful for debugging). \n"
                + "\t" + OPTION_ALLOWED_START_RANGE_FOR_OFFLINEGC + " <number>: specify what offLineGC free instruction id start range is allowed (useful for debugging). \n"
                + "\t" + OPTION_OFFLINE_GC_ALGORITHM_SELECTOR + " <number>: specify what offLineGC"
                + " algorithm to be used. The default is use all. \n "
                + " \t\t Can select multiple options seperated by commas\n"
                + "\t\t The options include: "
                + " PNR=" + StartMeOGC.PNR
                + ", FTT=" + StartMeOGC.FTT + ""
                + ", DAU=" + StartMeOGC.DAU + "\n"
                + "\t" + OPTION_KEEP_ID_WITH_MAX_SIZE_OFFLLINE_GC + " <number>: specify top n newIds with Max sized objects\n"
                + "\t" + OPTION_OFFLINE_GC_MAX_NEW_ID_GENERATED + " <number>: manually set the maximum number of new id generated (you may produce an error hence careful)\n"
                + "\t" + OPTION_INSERT_FREEMEMORY_INSTR_FOR_OGC_RESULTS + "<after # of instrs> <method-name> : to insert freeMemory instructions to produce offLineGC results."
                + "\n\t\t If method containst - then all methods are changed. \n"
                + "\t" + OPTION_NO_DEAD_CODE_REMOVAL + ": do not remove dead bytecode i.e functions, classes and fields. \n"
                //                + "\t" + OPTION_LV_STACK_OPTIM + ": optimize local variables and operand stack (for RAM). \n"
                + "\t" + OPTION_SLOT_SIZE_FOR_VSS + " <size>: block size for LV optimization \n"
                + "\t" + OPTION_NO_CLASS_FILE_VERIFICATION + ": Do not perform class file verification.\n"
                + "\t" + OPTION_NO_VERBOSE + ": Do not produce any output while compilation. \n"
                + "\t" + OPTION_FULL_COMPACTION + ": Use Full Compaction (FC) instead of default Limited Compaction (LC). \n"
                + "\t" + OPTION_REMOVE_DANGLING_REFE + ": Remove dangling references. Note, this option \n"
                + "\t is still under constrcution and currently only used for some results generation. \n"
                + "\t" + OPTION_GENERAL_PURPOSE_JVM + ": To compile a general purpose JVM, instead of a JVM that is optimized for each user program. \n"
                + "\t" + OPTION_GENERATE_SWITCH + ": Generate Big-Switch for instruction dispatch instead of"
                + " default labels based direct references \n"
                +"\t"+OPTION_VERIFY_TUK_FILE+" : Verify Tuk file for possible compilation errors \n"
                + "\t" + OPTION_CVCS + " <depth> <max-chunk-size> <change depth>: To generate CVCS "
                + "(Compile-time Variable Chunk Scheme) "
                + "file that is used to make chunks of variable sizes.\n\n"
                + "\tExample: StartMe<> ./input:AClass.class:./anotherinput ./output -algo s -noc 5 -cpos -osize");
    }

    void execute() {
        //todo: Move code out from here.
        codeLengthAtTheStartOfOptim = Oracle.getInstanceOf().getCurrentTotalCodeLength();
        RegisterCustomInstruction regCustInst = RegisterCustomInstruction.getInstanceOf();
        regCustInst.startOrEndOfAnOptimization();
        long timeTaken = System.currentTimeMillis();
        logStatsAtStart();
        try {
            setCurrentStateOfOptimization(OPTIM_STARTED_BUT_NOTHING_IS_FINISH);
            //do single instruction compaction
            singleInstructionOptimization();
            regCustInst.startOrEndOfAnOptimization();
            instructionUseInMultipleCombination = regCustInst.numberOfOpCodesavailable();

            //do multiple instruction compaction
            multipleInstructionsOptimization();
            regCustInst.startOrEndOfAnOptimization();

            instructionUseInMultipleCombination = instructionUseInMultipleCombination
                    - regCustInst.numberOfOpCodesavailable();
            generateMultInstCombStats();
            logHolder.addLog("+++++++++++++ 5: WASTED: number of unused opcodes = "
                    + regCustInst.numberOfOpCodesavailable());
            statHolder.addStat(StatGroups.BYTECODE_OPTIMIZATION,
                    "WASTED: number of unused opcodes",
                    regCustInst.numberOfOpCodesavailable());
            setCurrentStateOfOptimization(OPTIM_IS_ENDED);
            timeTaken = System.currentTimeMillis() - timeTaken;
            statHolder.addStat(StatGroups.BYTECODE_OPTIMIZATION, "Total Time", timeTaken);
        } catch (Exception d) {
            d.printStackTrace();
            Miscellaneous.exit();
        }
        //logHolder.addLog("End of bytecode optimization", true);
    }

    private void logStatsAtStart() {
        RegisterCustomInstruction regCustInst = RegisterCustomInstruction.getInstanceOf();
        BranchInstructionsHandler.getInstanceOf().restoreBranchInformation();
        logHolder.addLog("Starting bytecode optimization. Note: It could take some time. ", true);
        logHolder.addLog("Total instruction replaced ="
                + ReplaceInstrAWithB.getTotalInstructionReplaced() + "...");
        statHolder.addStat(StatGroups.BYTECODE_OPTIMIZATION,
                "Total instruction replaced (A with B)",
                ReplaceInstrAWithB.getTotalInstructionReplaced());

        statHolder.addStat(StatGroups.BYTECODE_OPTIMIZATION,
                "Total number of instructions ",
                CodeAtt.getTotalNumberOfInstructions());

        regCustInst.startOrEndOfAnOptimization();
        statHolder.addStat(StatGroups.BYTECODE_OPTIMIZATION,
                "Before bytecode optimization starts total opcodes available",
                regCustInst.numberOfOpCodesavailable());

        logHolder.addLog("Before starting optimization total unUsed Instructions = "
                + regCustInst.numberOfOpCodesavailable());

    }

    private void singleInstructionOptimization() {
        RegisterCustomInstruction regCustInst = RegisterCustomInstruction.getInstanceOf();
        regCustInst.startOrEndOfAnOptimization();
        if (!noOperandOpCodeCombination) {
            FreqOperandsCombiner.getInstanceOf().execute(percentThresholdOPPlusOP);
            logHolder.addLog("+++++++++++++ Done with operand+opcode combination: number of unused opcodes = "
                    + (256 - oracle.getAllOpcodeMnemonicsUseInCode().size()));
        }
        setCurrentStateOfOptimization(OPERAND_COMBINATION_IS_DONE);
        //Miscellaneous.println("3.1--------"+GenerateSwitch.getAllOpcodeMnemonicsUseInCode());

        if (executeCPAndOffsetOptimization) {
            CPAndOffSetChangedInstructions.getInstanceOf().execute();
            regCustInst.startOrEndOfAnOptimization();
            logHolder.addLog("+++++++++++++ Done with operand reduction: number of unused opcodes = "
                    + (256 - oracle.getAllOpcodeMnemonicsUseInCode().size()));
            //Miscellaneous.println("4.1--------"+GenerateSwitch.getAllOpcodeMnemonicsUseInCode());
        }
        setCurrentStateOfOptimization(OPERAND_REDUCTION_IS_DONE);

    }

    private void multipleInstructionsOptimization() {
        if (noMultCombination) {
            return;
        }
        RegisterCustomInstruction regCustInst = RegisterCustomInstruction.getInstanceOf();

        FreqMap.getInstanceOf().clear();
        InstructionsController instCont = InstructionsController.getInstanceOf();
        instCont.reCacheInstructions();
        logHolder.addLog("Finding bytecode frequencies ....");
        if (isStephenAlgo) {
            if (readCombinationsFromFile) {
                StephanAlgorithm.findNumberOfStephenCombination = 256;
            }
            StephanAlgorithm.getInstanceOf().execute();
        } else {
            instCont.generateFrequencies();
            Miscellaneous.println("******original code size = "
                    + InstructionsController.getInstanceOf().
                    getSizeOfInstructions());
            if (!readCombinationsFromFile) {
                InstructionFrequency.getInstanceOf().unifiedFrequency();
            }
        }
        //FreqMap.getInstanceOf().writeInFile(readCombFileName);
        if (readCombinationsFromFile) {
            new ReadCombinationsFromFile(readCombFileName).execute();
        }
        logHolder.addLog("Replacing new bytecodes ....");
        ByteCodeCombiner.getInstanceOf().execute();

        regCustInst.startOrEndOfAnOptimization();
        if (regCustInst.numberOfOpCodesavailable() != 0
                && lastUsedOpcodesSize != oracle.getAllOpcodeMnemonicsUseInCode().size()) {
            if (true) {
                lastUsedOpcodesSize = oracle.getAllOpcodeMnemonicsUseInCode().size();
                logHolder.addLog("----- Calling again with used="
                        + lastUsedOpcodesSize);
                multipleInstructionsOptimization();
            }
        }

    }

    private void generateMultInstCombStats() {
        RegisterCustomInstruction regCustInst = RegisterCustomInstruction.getInstanceOf();
        double reduction = codeLengthAtTheStartOfOptim
                - Oracle.getInstanceOf().getCurrentTotalCodeLength();
        double reductionPercent = ((double) 100.0) * ((reduction)
                / (double) codeLengthAtTheStartOfOptim);
        statHolder.addStat(StatGroups.MULTIPLE_BYTECODE_OPTIMIZATION,
                "Instruction used", instructionUseInMultipleCombination);
        statHolder.addStat(StatGroups.MULTIPLE_BYTECODE_OPTIMIZATION,
                "total reduction", reduction);
        statHolder.addStat(StatGroups.MULTIPLE_BYTECODE_OPTIMIZATION,
                "reduction per instruction",
                reduction / (double) instructionUseInMultipleCombination);

        statHolder.addStat(StatGroups.MULTIPLE_BYTECODE_OPTIMIZATION,
                "Total reducation %",
                StartMeAbstract.roundDouble(reductionPercent, 2));
        statHolder.addStat(StatGroups.MULTIPLE_BYTECODE_OPTIMIZATION,
                "Total registered combinations",
                regCustInst.getTotalNumberOfMultiInst());
        statHolder.addStat(StatGroups.MULTIPLE_BYTECODE_OPTIMIZATION,
                "Maxmimum length of combination",
                regCustInst.getMaxSizeOfMultiInst());
        statHolder.addStat(StatGroups.MULTIPLE_BYTECODE_OPTIMIZATION,
                "average length of combinations",
                (double) regCustInst.getTotalLengthOfMultiInst()
                / (double) regCustInst.getTotalNumberOfMultiInst());
        logHolder.addLog("+++ Total Bytecode reduction="
                + StartMeAbstract.roundDouble(reductionPercent, 2) + "%.... ", true);

    }
}
