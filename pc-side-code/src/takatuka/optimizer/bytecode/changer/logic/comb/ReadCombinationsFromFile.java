/*
 * Copyright 2010 Christian Schindelhauer, Peter Thiemann, Faisal Aslam, Luminous Fennell and Gidon Ernst.
 * All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 * 
 * This code is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3
 * only, as published by the Free Software Foundation.
 * 
 * This code is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 3 for more details (a copy is
 * included in the LICENSE file that accompanied this code).
 * 
 * You should have received a copy of the GNU General Public License
 * version 3 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 * 
 * Please contact Faisal Aslam 
 * (aslam AT informatik.uni-freibug.de or studentresearcher AT gmail.com)
 * if you need additional information or have any questions.
 */
package takatuka.optimizer.bytecode.changer.logic.comb;

import java.util.*;
import java.io.*;
import takatuka.optimizer.bytecode.changer.logic.freq.*;
import takatuka.optimizer.bytecode.changer.logic.*;
import takatuka.classreader.dataObjs.attribute.*;
import takatuka.vm.autoGenerated.vmSwitch.*;
import takatuka.classreader.logic.util.*;

/**
 * 
 * Description:
 * <p>
 * Step # 1: Get all the instructions (say using InstructionController) assume 
 * that it already have instruction set in right way. That is if the file has CPAndOffset 
 * operand optimization then instruction controller has that too.
 * 
 * Step # 2: See how much instruction to combine. Make the combination using InstructionFrequency class
 * 
 * Step #3: All the combination that are not in file remvoe them from InstructionFrequency map.
 *  
 * </p> 
 * @author Faisal Aslam
 * @version 1.0
 */
public class ReadCombinationsFromFile {

    private String fileName = null;
    private RegisterCustomInstruction regCustInst = RegisterCustomInstruction.getInstanceOf();

    public ReadCombinationsFromFile(String fileName) {
        this.fileName = fileName;
    }

    public void execute() {
        try {
            Vector lines = readLinesFromFile();
            int maxComb = Integer.parseInt((String) lines.remove(0));
            InstructionFrequency.numberOfInstructionCombined = maxComb;
            //createMap(maxComb);
            limitMapToValidValues(lines);
        } catch (Exception d) {
            d.printStackTrace();
            Miscellaneous.exit();
        }
    }

    private void limitMapToValidValues(Vector lines) {
        FreqMap newMap = new FreqMap();
        FreqMap oldMap = FreqMap.getInstanceOf(); //use it to find stuff 
        InstructionsCombined value = null;
        Vector keys = oldMap.getAllKeysSorted();
        int size = regCustInst.numberOfOpCodesavailable();
        for (int index = 0; index < keys.size() && newMap.size() < size; index++) {
            String key = (String) keys.elementAt(index);
            if (lines.contains(key)) {
                value = oldMap.getValue(key).instComb;
                newMap.put(value, -1, value.getInstructions());
                regCustInst.register(value, value.getInstructions());
            }
        }
        FreqMap.getInstanceOf().setMap(newMap);
    }

    private void createMap(int length) {
        InstructionsController instCont = InstructionsController.getInstanceOf();
        InstructionFrequency instFreq = InstructionFrequency.getInstanceOf();
        InstructionFrequency.numberOfInstructionCombined = length;
        //InstructionFrequency.countCombinationAsSingle = false;
        InstructionFrequency.shouldFunction = true;
        instFreq.clear();
        Instruction inst = null;
        for (int index = 0; index < instCont.getCurrentSize(); index++) {
            inst = (Instruction) instCont.get(index);
            instFreq.execute(inst);
        }
    }

    private Vector readLinesFromFile() throws Exception {
        RandomAccessFile rm = new RandomAccessFile(fileName, "r");
        rm.seek(0);
        Vector ret = new Vector();
        while (rm.getFilePointer() < rm.length()) {
            String line = rm.readLine();
            //Miscellaneous.println("line read "+ line);
            ret.addElement(line);
        }
        rm.close();
        return ret;
    }
}
