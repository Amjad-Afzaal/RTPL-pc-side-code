/*
 * Copyright 2010 Christian Schindelhauer, Peter Thiemann, Faisal Aslam, Luminous Fennell and Gidon Ernst.
 * All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 * 
 * This code is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3
 * only, as published by the Free Software Foundation.
 * 
 * This code is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 3 for more details (a copy is
 * included in the LICENSE file that accompanied this code).
 * 
 * You should have received a copy of the GNU General Public License
 * version 3 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 * 
 * Please contact Faisal Aslam 
 * (aslam AT informatik.uni-freibug.de or studentresearcher AT gmail.com)
 * if you need additional information or have any questions.
 */
package takatuka.optimizer.bytecode.changer.logic.freq;

import takatuka.optimizer.bytecode.changer.logic.comb.InstructionsCombined;
import java.util.*;

import takatuka.classreader.logic.util.*;
import takatuka.classreader.dataObjs.attribute.*;
import takatuka.classreader.logic.constants.*;
import takatuka.classreader.dataObjs.*;
import takatuka.classreader.logic.factory.FactoryFacade;
import takatuka.classreader.logic.factory.FactoryPlaceholder;
import takatuka.optimizer.bytecode.branchSetter.dataObjs.attributes.BHInstruction;
import takatuka.optimizer.bytecode.branchSetter.logic.BranchInstructionsHandler;
import takatuka.optimizer.bytecode.changer.logic.*;
import takatuka.vm.autoGenerated.vmSwitch.RegisterCustomInstruction;

/**
 * <p>Title: </p>
 *
 * <p>Description:
 *
 * Use to check the frequency of instructions so that we can extend instruction
 * set that give us more speed and reduce code size.
 * This class should not be used normally
 * it is because it will slow down things for no good reasons.
 *
 * </p>
 *
 * @author Faisal Aslam
 * @version 1.0
 */
public class InstructionFrequency {
    public static int delme = 0;
    //private static Vector unUsedBytecodes = null;
    private long totalSavings = 0;
    private static long totalInstructions = 0;
    private FreqMap fMap = FreqMap.getInstanceOf();
    private static int arrivalTime = 0;
    /**
     * Keeps the last five instructions. Should never keep more than five
     */
    private Vector lastNInstructions = new Vector();
    public static int numberOfInstructionCombined = 16;
    //private int extraInstrCombToRemoveOverLapping = 5;
    private int maxCombinedInstr = 0;
    public static boolean shouldFunction = true;
    private static final InstructionFrequency instFreq = new InstructionFrequency();
    public static boolean countCombinationAsSingle = false;
    private static FactoryFacade factory = FactoryPlaceholder.getInstanceOf().getFactory();

    public void clear() {
        try {
            //unUsedBytecodes = JavaInstructionsOpcodes.getAllPossibleOpCodes();
            totalSavings = 0;
            totalInstructions = 0;
            fMap.clear();
            lastNInstructions = new Vector();
            arrivalTime = 0;
        } catch (Exception d) {
            d.printStackTrace();
            Miscellaneous.exit();
        }

    }

    private InstructionFrequency() {
        clear();
    }

    /**
     * being a singleton object this is the only way to get its instance.
     * @return
     */
    public static final InstructionFrequency getInstanceOf() {
        return instFreq;
    }

    /**
     * this function combines instructions upto numberOfInstructionCombined instructions
     * and then put them in a map:
     *          map key is combined-opcodes and 
     *          map value is frequency of those combined opcodes 
     *        
     * 
     */
    private void combine() {
        try {
            InstructionsCombined key = null;
            int size = lastNInstructions.size();
            for (int start = 0; start < size - 1; start++) {
                key = new InstructionsCombined();
                for (int index = start; index < size; index++) {
                    BHInstruction temp = (BHInstruction) lastNInstructions.get(index);
                    key.addInstruction(temp);
                }

                if (key.getInstructions().size() != 1 && key.isValidCombination()) {
                    //Miscellaneous.println(".... I am here key = " + key.getMnemonic());
                    if (fMap.getValue(key) == null) {
                        fMap.put(key, arrivalTime, key.getInstructions());
                    } else {
                        fMap.inc(key, arrivalTime);
                    }
                }
            }

        } catch (Exception d) {
            d.printStackTrace();
            Miscellaneous.exit();
        }
    }

    public int getMaxNumberInstCombined() {
        return maxCombinedInstr;
    }

    public static int lengthOfInstrctionsCombined(Vector instructions) {
        if (countCombinationAsSingle) {
            return instructions.size();
        } else {
            int size = 0;
            for (int loop = 0; loop < instructions.size(); loop++) {
                Instruction inst = (Instruction) instructions.elementAt(loop);
                if (inst instanceof InstructionsCombined) {
                    size = size + ((InstructionsCombined) inst).getNumberOfSimpleInsturction();
                } else {
                    size++;
                }
            }
            return size;
        }

    }

    private boolean instrAllowedOnlyAtStartOfCombination(BHInstruction instr,
            Vector<BHInstruction> currentCandidates) {
        /*BranchInstructionsHandler instHandler = BranchInstructionsHandler.getInstanceOf();
        if (instHandler.isBranchSrcAndDestInstruction(instr) ||
        instHandler.isBranchTargetInstruction(instr)) {
        return true;
        }
        /*if ((currentCandidates.size() != 0 && 
        currentCandidates.get(0).isBranchTarget() &&
        instr.isBranchSource())) {
        return true;
        }*/
        return false;
    }


    /**
     * From here we start. 
     * 1. keep last fours instruction saved
     * 2. When the fifth instruction come then remove from the beginning 
     * and add it at the end.
     * 3. call combine which combine insruction in all order sequences.
     * 
     * @param inst
     */
    public void execute(Instruction instInput) {

//     Miscellaneous.println("can you see me " + instInput.getMnemonic());
        BHInstruction inst = (BHInstruction) instInput;
        if (!shouldFunction) {
            return;
        }
        arrivalTime++;

        totalInstructions = totalInstructions + inst.length();
        if (inst.shouldOnlyComeAtTheBeginning()) {
            lastNInstructions.clear();
        }
        lastNInstructions.addElement(inst);

        //so size is now never more than allowed number
        while (lengthOfInstrctionsCombined(lastNInstructions) > numberOfInstructionCombined) {
            lastNInstructions.remove(0);
        }

        if (lastNInstructions.size() > maxCombinedInstr) {
            maxCombinedInstr = lastNInstructions.size();
        }
        combine();

        //Cannot combine bytecode of two functions etc
        if (inst.shouldOnlyComeAtTheEnd()) { //these are also breaker instructions
            lastNInstructions.removeAllElements();
        }
        
    }

    /**
     * Now combination are 1 freq or 0 freq. In case of top n (which could
     * have opcode defined) we assign 1 freq. Rest are assigned 0 freq.
     */
    public void unifiedFrequency() {
        Vector freqKeys = fMap.getAllKeys();
        QuickSort.sort(freqKeys, new FreqMapValueComparator());
        RegisterCustomInstruction regCusInst = RegisterCustomInstruction.getInstanceOf();
        int avilableOpcodes = regCusInst.numberOfOpCodesavailable();
        for (int loop = 0; loop < freqKeys.size(); loop++) {
            FreqMapValue value = fMap.getValue((String) freqKeys.elementAt(loop));
            InstructionsCombined instComb = value.instComb;
            if (loop < avilableOpcodes) {
                fMap.resetFreq(instComb);
            //Miscellaneous.println("our gloden instruction ---> " + instComb.getInstructions().size() + ", " + value.freq + ",    " +
            //      freqKeys.elementAt(loop));
            } else {
                fMap.remove(instComb);
            //fMap.put(instComb, 0);
            }
        }
    }

    @Override
    public String toString() {
        totalSavings = 0;
        String ret = " Number of never used Instrction=" +
                RegisterCustomInstruction.getInstanceOf().numberOfOpCodesavailable();
        ret = ret + "\n , total Instruction size= " + totalInstructions + "\n";
        Vector freqKeys = fMap.getAllKeys();
        QuickSort.sort(freqKeys, new FreqMapValueComparator());
        //Miscellaneous.println("Note that all instruction are in order of their appearance. That means instruction on the left comes before instruction on the right hand side");

        for (int loop = 0; loop < RegisterCustomInstruction.getInstanceOf().
                numberOfOpCodesavailable() -
                CPAndOffSetChangedInstructions.getInstanceOf().totalCreatedNewInsturctions() &&
                loop < freqKeys.size(); loop++) {
            String key = (String) freqKeys.elementAt(loop);
            FreqMapValue fmValue = fMap.getValue(key);
            ret = ret + fmValue.instComb.getInstructionId() + ":";
            ret = ret + fmValue.instComb.getMnemonic() + ", " + fmValue.freq + "*" +
                    fmValue.instComb.getSavings() + "=" + (fmValue.freq * fmValue.instComb.getSavings()) + "";
            totalSavings += (fmValue.freq * fmValue.instComb.getSavings());
            ret = ret + ", isBranchSrc=" + BranchInstructionsHandler.getInstanceOf().isBranchSourceInstruction(fmValue.instComb);
            ret = ret + ", isBranchTarget=" + BranchInstructionsHandler.getInstanceOf().isBranchTargetInstruction(fmValue.instComb);
            ret = ret + "\n";

        //Miscellaneous.println("here = "+ret+ " total Savings = "+totalSavings+"\n\n\n\n");
        //ret = "";
        }
        ret = ret + "\n\n\t\tTotalSavings= ******************" + totalSavings;
        return ret;
    }

    public InstructionsCombined removeHighestFreqMulSavingCombination() { 
        //Miscellaneous.println(fMap);
        FreqMapValue value = fMap.getAndRemoveMaxSavingsValue();
        InstructionsCombined comb1 = null;
        if (value != null) {
            comb1 = value.instComb;
        }
       return comb1;
    }

    /**
     * return vector of FreqMap Keys  sorted by Freq*saving values
     * @return
     */
    public Vector getHighestFreqMulSavingCombinationsKeys() {
        Vector freqKeys = fMap.getAllKeys();
        QuickSort.sort(freqKeys, new FreqMapValueComparator());
        return freqKeys;
    }

    public static void main(String args[]) throws Exception {
        InstructionFrequency instFreq1 = InstructionFrequency.getInstanceOf();
        Miscellaneous.println(JavaInstructionsOpcodes.AALOAD + ", " + JavaInstructionsOpcodes.AASTORE +
                ", " + JavaInstructionsOpcodes.ACONST_NULL + ", " + JavaInstructionsOpcodes.ANEWARRAY);
        /*
        instFreq1.execute(factory.createInstruction(JavaInstructionsOpcodes.AALOAD, new Un(), 1, 1, null));
        instFreq1.execute(factory.createInstruction(JavaInstructionsOpcodes.AASTORE, new Un(), 1, 1, null));
        instFreq1.execute(factory.createInstruction(JavaInstructionsOpcodes.ACONST_NULL, new Un(), 1, 1, null));
        instFreq1.execute(factory.createInstruction(JavaInstructionsOpcodes.ANEWARRAY, new Un(), 1, 1, null));
        instFreq1.execute(factory.createInstruction(JavaInstructionsOpcodes.AALOAD, new Un(), 1, 1, null));
        instFreq1.execute(factory.createInstruction(JavaInstructionsOpcodes.AASTORE, new Un(), 1, 1, null));
        instFreq1.execute(factory.createInstruction(JavaInstructionsOpcodes.ACONST_NULL, new Un(), 1, 1, null));
        instFreq1.execute(factory.createInstruction(JavaInstructionsOpcodes.ANEWARRAY, new Un(), 1, 1, null));
        instFreq1.execute(factory.createInstruction(JavaInstructionsOpcodes.AALOAD, new Un(), 1, 1, null));
        instFreq1.execute(factory.createInstruction(JavaInstructionsOpcodes.AASTORE, new Un(), 1, 1, null));
        instFreq1.execute(factory.createInstruction(JavaInstructionsOpcodes.ACONST_NULL, new Un(), 1, 1, null));
        instFreq1.execute(factory.createInstruction(JavaInstructionsOpcodes.ANEWARRAY, new Un(), 1, 1, null));
        instFreq1.execute(factory.createInstruction(JavaInstructionsOpcodes.RETURN, new Un(), 1, 1, null));
*/
        Miscellaneous.println("here " + instFreq1);
    }
}
