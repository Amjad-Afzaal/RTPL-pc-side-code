/*
 * Copyright 2010 Christian Schindelhauer, Peter Thiemann, Faisal Aslam, Luminous Fennell and Gidon Ernst.
 * All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 * 
 * This code is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3
 * only, as published by the Free Software Foundation.
 * 
 * This code is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 3 for more details (a copy is
 * included in the LICENSE file that accompanied this code).
 * 
 * You should have received a copy of the GNU General Public License
 * version 3 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 * 
 * Please contact Faisal Aslam 
 * (aslam AT informatik.uni-freibug.de or studentresearcher AT gmail.com)
 * if you need additional information or have any questions.
 */
package takatuka.optimizer.bytecode.changer.logic.freq.stephan;

import takatuka.classreader.dataObjs.attribute.*;
import java.util.*;
import takatuka.optimizer.bytecode.changer.logic.freq.*;
import takatuka.optimizer.bytecode.changer.logic.comb.*;
import takatuka.classreader.dataObjs.*;
import takatuka.classreader.logic.factory.*;
import takatuka.classreader.logic.logAndStats.*;
import takatuka.optimizer.bytecode.changer.logic.*;
import takatuka.vm.autoGenerated.vmSwitch.*;
import takatuka.classreader.logic.util.*;

/**
 * 
 * Description:
 * <p>
 * This algorithm was first suggested by Stephen Ruehrup during our discussion. Hence
 * named accordingly. It works as follows
 * 
 * - a) Find freq of all the combinations. 
 * - b) add combination with highest freq*saving in set A.
 * - b) replace all the occurances of that combination from the instruction set
 *      with a special symbol indicating break in instruction combination making.
 * - if (size of set A is less than number of combination needed) then
 *    go back to step a) otherwise stop.
 *
 * 
 * </p> 
 * @author Faisal Aslam
 * @version 1.0
 */
public class StephanAlgorithm {

    private static final StephanAlgorithm stAlgo = new StephanAlgorithm();
    private TreeMap selectedCombinations = new TreeMap();
    private int totalSavings = 0;
    InstructionFrequency instFreq = InstructionFrequency.getInstanceOf();
    private InstructionsController InstrCont =
            InstructionsController.getInstanceOf();
    private Vector backupStategyFreq = null;
    //public static final String ANTICIPATED_SAVINGS = "anticipated_savings";
    public static final String ALGORITHM = "ALGORITHM";
    public static int findNumberOfStephenCombination = -1;
    //as it can be now more than n
    private int maxCombined = 0;
    private static FactoryFacade factory = FactoryPlaceholder.getInstanceOf().getFactory();
    private RegisterCustomInstruction regCustInst = RegisterCustomInstruction.getInstanceOf();

    public static StephanAlgorithm getInstanceOf() {
        return stAlgo;
    }
  
    private InstructionsCombined getBestCombinationWhenDoneWithStephen() {
        if (backupStategyFreq == null) {
            InstrCont.reCacheInstructions();
            instFreq.clear();
            for (int loop = 0; loop < InstrCont.getCurrentSize(); loop++) {
                Instruction stpInst = (Instruction) InstrCont.get(loop);
                // Miscellaneous.println("finding freq of =" + stpInst.getMnemonic());
                instFreq.execute(stpInst);
            }
            backupStategyFreq = instFreq.getHighestFreqMulSavingCombinationsKeys();
        }
        if (backupStategyFreq.size() == 0) {
            return null;
        }
        String key = (String) backupStategyFreq.remove(0);
        FreqMapValue fmValue = FreqMap.getInstanceOf().getValue(key);

        if (fmValue == null || 
                BCCompactionCost.getInstanceOf().getTotalReduction(fmValue) < 0) {
            return null;
        }
        return fmValue.instComb;
    }

    private Vector getBestCombinations() {
        InstructionsCombined bestComb = null;
        //clear old frequencies
        instFreq.clear();
        //step 2:
        Instruction stpInst = null;
        for (int loop = 0; loop < InstrCont.getCurrentSize(); loop++) {
            stpInst = (Instruction) InstrCont.get(loop);
            //
            //Miscellaneous.println("finding freq of =" + stpInst.getMnemonic());
            instFreq.execute(stpInst);
        //Miscellaneous.println(" me me 110"+instFreq);
        }
        //step 3:
        bestComb = instFreq.removeHighestFreqMulSavingCombination();
        Vector<InstructionsCombined> ret = new Vector();
        ret.addElement(bestComb);
        while (true) {
            InstructionsCombined comb2 = instFreq.removeHighestFreqMulSavingCombination();
            if (comb2 == null || checkOverLap(ret, comb2)) {
                break;
            } else {
                ret.addElement(comb2);
            }
        }
        return ret;
    }

    /**
     * return false if latest overlap with any element of alreadyselected combination
     * @param alreadySelected
     * @param lastest
     * @return
     */
    private boolean checkOverLap(Vector<InstructionsCombined> alreadySelected, InstructionsCombined latest) {

        for (int loop = 0; loop < alreadySelected.size(); loop++) {
            InstructionsCombined toCheckWith = alreadySelected.elementAt(loop);
            if (latest.overlap(toCheckWith)) {
                //Miscellaneous.println("\n\nWe found overlap " + latest.getMnemonic() + "\n, " + toCheckWith.getMnemonic());
                return true;
            }
        }
        return false;
    }

    /**
     * from here we start.
     * step 0: initialization
     * step 1: get all code Attributes
     * step 2: for each instruction in the code attribute call InstructionFrequency's execute
     * step 3: save the highest freq*saving combination in the selectedCombination vector.
     * Step 4: later todo
     * Step 5: In the starting instruction of the highest frequency set boolean isTaken = true and
     * combinationEndAfter = length of combination.
     * Step 6: go back to step 2 if selectedCombination size is less than unUsed allCachedStephanInstructions.
     * However always skip instruction with isTaken = true or in range of combinationEndAfter
     * It implies start new combination making after the skip.
     * Step 7: Set the FreqMap with selectedCombinations
     */
    public void execute() {
        //Step 1:        
        int size = regCustInst.numberOfOpCodesavailable();
        selectedCombinations.clear();
        if (findNumberOfStephenCombination != -1) {
            size = findNumberOfStephenCombination;
        }
        backupStategyFreq = null;
        InstructionFrequency.shouldFunction = true;
        InstructionsCombined bestComb = null;
        Vector<InstructionsCombined> bestCombVec = new Vector();
        while (selectedCombinations.size() < size) {
            if (backupStategyFreq == null) {
                if (bestCombVec.size() == 0) {
                    bestCombVec = getBestCombinations();
                }
                if (bestCombVec.size() != 0) {
                    bestComb = bestCombVec.remove(0);
                } else {
                    bestComb = null;
                }
            }
            if (bestComb == null || backupStategyFreq != null) {
                //if (true) break;
                bestComb = getBestCombinationWhenDoneWithStephen();
                while (bestComb != null && selectedCombinations.get(bestComb.getMnemonic()) != null) {
                    bestComb = getBestCombinationWhenDoneWithStephen();
                }
                if (bestComb != null) {
                //Miscellaneous.println("backup Selected:" + bestComb.getMnemonic());
                }
            } else {
                if (selectedCombinations.get(bestComb.getMnemonic()) != null) {
                    Miscellaneous.printlnErr("Error #304 while doing bytcode optimiation " + bestComb.getMnemonic());
                    Miscellaneous.exit();
                }
                // Step 5:
                checkAndmarkBestCombination(bestComb); //Too slow. Rewrite this function
                bestComb.setSavings(0);
            }

            if (bestComb != null) {
                //Miscellaneous.println(" best chosen ------ " + bestComb);

                selectedCombinations.put(bestComb.getMnemonic(), bestComb);
                if (bestComb.getNumberOfSimpleInsturction() > maxCombined) {
                    maxCombined = bestComb.getNumberOfSimpleInsturction();
                // Miscellaneous.println("**** maxCombined = "+maxCombined+"\n");
                }
            } else {
                break;
            }
        //+"++++++++++++++++++"+ bestComb.getSimpleInstCombined().getMnemonic());

        }
        //Miscellaneous.println("--------see me ---- "+selectedCombinations);
        populateFreqMap();
        InstructionFrequency.numberOfInstructionCombined = maxCombined;
        StatsHolder.getInstanceOf().addStat(ALGORITHM, "multi_iteration");

    }

    private void populateFreqMap() {
        FreqMap fMap = FreqMap.getInstanceOf();
        fMap.clear();
        int size = selectedCombinations.size();
        InstructionsCombined comb = null;
        Vector selectedCombValue = new Vector(selectedCombinations.values());
        for (int loop = 0; loop < size; loop++) {
            comb = (InstructionsCombined) selectedCombValue.elementAt(loop);
            InstructionsCombined temp = InstructionsCombined.getSimpleInstCombined(comb.getInstructions());
            fMap.put(temp, -1, temp.getInstructions());
            comb.setSavings(-1);
        //fMap.put(comb, -1);
        }
    }

    private Instruction specialBreakStephInst() {
        try {
            return factory.createInstruction(-1, new Un(), null);
        } catch (Exception d) {
            d.printStackTrace();
            Miscellaneous.exit();
        }
        return null;
    }

    /**
     * traverse all the instruction and mark the combination where ever it occure
     * @param bestComb
     */
    private void checkAndmarkBestCombination(InstructionsCombined bestComb) {
        //Miscellaneous.println(" Mnemonic = " + bestComb.getMnemonic());
        //if (bestComb.getMnemonic().equals("ICONST_0+ISTORE_1+ICONST_5+ISTORE_2+ALOAD_0+ARRAYLENGTH+IFNE")) {

        //}
        Vector cacheInstructions = new Vector();
        boolean markedOnce = false;
        Instruction inst = null;
        for (int loop = 0; loop < InstrCont.getCurrentSize(); loop++) {
            inst = (Instruction) InstrCont.get(loop);
//            if (inst.getOpCode() == -1) {
//                continue;
//            }
            cacheInstructions.addElement(inst);
            while (InstructionsCombined.getSimpleInstCombined(cacheInstructions).size() > bestComb.getNumberOfSimpleInsturction()) {
                cacheInstructions.remove(0);
            }
            //Miscellaneous.println("another Instruction = " + inst.getMnemonic());
            boolean isSameInst = isSameCombination(cacheInstructions, bestComb);
            if (isSameInst) {
                // Miscellaneous.println("Marked  Marked");
                markStephenInstruction(cacheInstructions, bestComb, loop);
                loop = loop - cacheInstructions.size() + 1; //because of removals
                cacheInstructions.clear();
                markedOnce = true;
            }
        }
        if (!markedOnce) {
            Miscellaneous.printlnErr(" Not marked once " + bestComb.getMnemonic());
            Miscellaneous.exit();
        }
    // Miscellaneous.println(bestComb.getMnemonic()+"\n\n  controller = " + InstrCont.toString());
    }

    private void markStephenInstruction(Vector stephenInst,
            InstructionsCombined bestComb, int combEndIndex) {
        try {
            int index = 0;
            //InstrCont.add(currentIndexOfInstruction, specialBreakStephInst());
            InstrCont.add(combEndIndex + 1, bestComb);
            for (int loop = 0; loop < stephenInst.size(); loop++) {
                index = combEndIndex - loop;
                Instruction stepInst = (Instruction) InstrCont.get(index);
                //Miscellaneous.println(">>>>>>>>>>>>>> " + stepInst.getMnemonic());
                InstrCont.remove(index);
            }
        //StephanInstruction stepInst = (StephanInstruction) stephenInst.
        //      elementAt(/*loop*/stephenInst.size()-1);
        //stepInst.isTaken = true;
        //stepInst.combinationEndAfter = stephenInst.size();
        } catch (Exception d) {
            d.printStackTrace();
            Miscellaneous.exit();
        }

    }

    /**
     * We only compare opcodes in this function. Hence two instruction with totally
     * different operands will be same if they have same opcodes.
     * @param stephenInsts
     * @param comb
     * @return
     */
    private boolean isSameCombination(Vector stephenInsts,
            InstructionsCombined comb) {
        InstructionsCombined comb2 = new InstructionsCombined();
        comb2.addInstructions(stephenInsts);
        //Miscellaneous.println("compare : " + comb2.getMnemonic() + ",  " + comb.getMnemonic());
        if (comb2.getMnemonic().equals(comb.getMnemonic()) &&
                comb2.isValidCombination()) {
            return true;
        }
        return false;
    }

    private void debug_PrintSelectedCombinations() {
        int size = this.selectedCombinations.size();
        Vector values = new Vector(selectedCombinations.values());
        for (int loop = 0; loop < size; loop++) {
            InstructionsCombined comb = (InstructionsCombined) values.elementAt(loop);
            Miscellaneous.println("selected =" + comb.getMnemonic());
        }
    }

    private void createTestScenario(String str) throws Exception {
        //InstructionFrequency intFreq = InstructionFrequency.getInstanceOf();
        InstructionFrequency.shouldFunction = false;

        //Instruction.offFreq = true;
        for (int loop = 0; loop < str.length(); loop++) {
            char c = str.charAt(loop);
            int opCode = Integer.parseInt(c + "");

            Instruction inst = factory.createInstruction(opCode, new Un(), null);
            InstrCont.add(inst);
        //intFreq.execute(inst);
        //Miscellaneous.println(" added opcode, Mnemonic ={" + opCode + ", " + inst.getMnemonic() + "}");
        //Miscellaneous.println(" ------------- \n"+intFreq);
        }
    }

    private void runTestScenario() {
        StephanAlgorithm.getInstanceOf().execute();
    }

    public static void main(String args[]) throws Exception {
        Miscellaneous.println("Testing Stephen Algorithm");
        //createTestScenario("123123123");
        //runTestScenario();
        StephanAlgorithm.getInstanceOf().debug_PrintSelectedCombinations();
    //Miscellaneous.println();
    }
}
