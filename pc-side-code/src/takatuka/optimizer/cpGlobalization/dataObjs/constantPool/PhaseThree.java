/*
 * Copyright 2010 Christian Schindelhauer, Peter Thiemann, Faisal Aslam, Luminous Fennell and Gidon Ernst.
 * All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 * 
 * This code is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3
 * only, as published by the Free Software Foundation.
 * 
 * This code is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 3 for more details (a copy is
 * included in the LICENSE file that accompanied this code).
 * 
 * You should have received a copy of the GNU General Public License
 * version 3 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 * 
 * Please contact Faisal Aslam 
 * (aslam AT informatik.uni-freibug.de or studentresearcher AT gmail.com)
 * if you need additional information or have any questions.
 */
package takatuka.optimizer.cpGlobalization.dataObjs.constantPool;

import takatuka.vm.autoGenerated.*;
import java.util.*;
import takatuka.classreader.dataObjs.*;
import takatuka.classreader.dataObjs.constantPool.*;
import takatuka.classreader.dataObjs.constantPool.base.*;
import takatuka.classreader.logic.constants.*;
import takatuka.classreader.logic.factory.*;
import takatuka.optimizer.appendCP.logic.*;
import takatuka.optimizer.cpGlobalization.dataObjs.constantPool.GCP.*;
import takatuka.optimizer.cpGlobalization.logic.util.*;
import takatuka.classreader.logic.util.*;

/**
 * <p>Title: </p>
 * <p>Description:
 *
 * In this phase we globalize all FieldRefInfo, MethodRefInfo and
 * InterfaceMethodRefInfo.
 *
 * </p>
 * @author Faisal Aslam
 * @version 1.0
 */
public class PhaseThree implements Phase {

    private GlobalConstantPool pOne = GlobalConstantPool.getInstanceOf();
    private FactoryFacade factory = FactoryPlaceholder.getInstanceOf().
            getFactory();
    private static final PhaseThree phaseThree = new PhaseThree();
    private HashMap uniques = new HashMap();
    private final Oracle oracle = Oracle.getInstanceOf();

    protected PhaseThree() {
        super();
    }

    public boolean isPhaseTag(int tag) {
        if (tag == TagValues.CONSTANT_Fieldref ||
                tag == TagValues.CONSTANT_Methodref ||
                tag == TagValues.CONSTANT_InterfaceMethodref) {
            return true;
        }
        return false;
    }

    public boolean isPhaseElm(InfoBase obj) {
        int tag = obj.getTag().intValueUnsigned();
        return isPhaseTag(tag);
    }

    public void removeAllDuplicates(Phase phase) throws Exception {
        pOne.removeAllDuplicates(phase);
    }

    public static PhaseThree getInstanceOf() {
        return phaseThree;
    }

    private void globalizeRefInfos() throws Exception {
        globalizeReferenceInfo(TagValues.CONSTANT_Fieldref);
        globalizeReferenceInfo(TagValues.CONSTANT_Methodref);
        globalizeReferenceInfo(TagValues.CONSTANT_InterfaceMethodref);
    }

    private void gloablizeFieldMethodInfoAndThisSuperPointers() throws Exception {
        ClassFileController classCont = ClassFileController.getInstanceOf();
        for (int loop = 0; loop < classCont.getCurrentSize(); loop++) {
            ClassFile.currentClassToWorkOn = (ClassFile) classCont.get(loop);

            globalizeFieldMethodInfo(ClassFile.currentClassToWorkOn.getFieldInfoController());
            globalizeFieldMethodInfo(ClassFile.currentClassToWorkOn.getMethodInfoController());

            gloalizeThisPointer(ClassFile.currentClassToWorkOn);
            gloalizeSuperPointer(ClassFile.currentClassToWorkOn);
        }
    }

    public void execute() throws Exception {
        globalizeRefInfos();
        gloablizeFieldMethodInfoAndThisSuperPointers();

        fixReferenceInfoClassIndex();
        markNonDuplicates();
        removeAllDuplicates(this);
        //Miscellaneous.println(takatuka.classreader.logic.util.StringUtil.getString(pOne.getAllforDebugging(TagValues.CONSTANT_Fieldref),
        //        "\n\n"));

        GenerateKeepReferences.getInstanceOf().execute();
        //Miscellaneous.println(takatuka.classreader.logic.util.StringUtil.getString(pOne.getAllforDebugging(TagValues.CONSTANT_Fieldref),
        //        "\n\n"));

        StaticCreator.getInstanceOf().moveStaticFieldReferences();

        pOne.setGroupReferenceCount(TagValues.CONSTANT_Fieldref);
        pOne.sort(PhaseValuesComparator.getInstanceOf(), this);
    }

    private ReferenceInfo createRefInfo(int tag, int classIndexInt, Un nameAndTypeIndex) {
        ReferenceInfo refInfo = null;
        try {
            Un classIndex = factory.createUn(classIndexInt).trim(2);
            if (tag == TagValues.CONSTANT_Fieldref) {
                refInfo = factory.createFieldRefInfo(classIndex, nameAndTypeIndex);
            } else if (tag == TagValues.CONSTANT_Methodref) {
                refInfo = factory.createMethodRefInfo(classIndex, nameAndTypeIndex);
            } else if (tag == TagValues.CONSTANT_InterfaceMethodref) {
                refInfo = factory.createInterfaceMethodRefInfo(classIndex, nameAndTypeIndex);
            } else {
                Miscellaneous.printlnErr("Some error while globalization ");
                Miscellaneous.exit();
            }
        } catch (Exception d) {
            d.printStackTrace();
            Miscellaneous.exit();
        }
        return refInfo;
    }

    private void markNonDuplicates() {
        markNonDuplicates(TagValues.CONSTANT_Fieldref);
        markNonDuplicates(TagValues.CONSTANT_Methodref);
        markNonDuplicates(TagValues.CONSTANT_InterfaceMethodref);
    }

    private void markNonDuplicates(int tag) {
        String key = null;
        try {
            int size = pOne.getCurrentSize(tag);
            for (int index = 0; index < size; index++) {
                if (pOne.get(index, tag) instanceof EmptyInfo) {
                    continue;
                }
                ReferenceInfo rBase = (ReferenceInfo) pOne.get(index, tag);
                key = KeyUtil.keymaker(rBase.getIndex(), rBase.getNameAndTypeIndex(),
                        tag);
                if (uniques.get(key) == null) {
                    //Miscellaneous.println("Keep " + ", " + key + ", " + index);
//                Miscellaneous.println(keyp1+", "+keyp2);
                    pOne.setMayBeDuplicate(index, tag, false);
                    uniques.put(key, "");
                //globalMap.put(key, rBase);
                } else {
                    //Miscellaneous.println("Delete" + ", " + key);
                    pOne.setMayBeDuplicate(index, tag, true);
                }
            }
        } catch (Exception d) {
            d.printStackTrace();
            Miscellaneous.exit();
        }
    }

    /**
     * The field/method might be in a different class and the pointer in the referenceInfo
     * might be pointing to a different class. Hence the objective of this function
     * is that class_pointer in a referenceInfo points to exactly a same class which
     * actually has the field/method.
     */
    private void fixReferenceInfoClassIndex() {
        fixReferenceInfoClassIndex(TagValues.CONSTANT_Fieldref);
        fixReferenceInfoClassIndex(TagValues.CONSTANT_Methodref);
    //fixReferenceInfoClassIndex(TagValues.CONSTANT_InterfaceMethodref);
    }

    private void fixReferenceInfoClassIndex(int tag) {

        int size = pOne.getCurrentSize(tag);
        ClassFile cFile = null;
        for (int index = 0; index < size; index++) {
            int cpIndex = index;
            if (pOne.get(index, tag) instanceof EmptyInfo) {
                continue;
            }
            ReferenceInfo ref = (ReferenceInfo) pOne.get(index, tag);
            cFile = oracle.getClass(ref.getIndex(), pOne);
            //int nAtIndex = ref.getNameAndType().intValueUnsigned();
            //int nameIndex = ((NameAndTypeInfo) pOne.get(nAtIndex, TagValues.CONSTANT_NameAndType)).getIndex().intValueUnsigned();
            //String name = ((UTF8Info) pOne.get(nameIndex, TagValues.CONSTANT_Utf8)).convertBytes();
            //Miscellaneous.println(" B =" + name);
            if (cFile != null) {
                //Miscellaneous.println(" B " + cFile.getFullyQualifiedClassName());
                int classIndex = getReferenceInfoClassIndex(ref, tag, cFile);
                if (ref.getIndex().intValueUnsigned() != classIndex && classIndex != -1) {
                    /*ReferenceInfo newRef = createRefInfo(tag, classIndex, ref.getNameAndType());
                    cpIndex = oracle.existReferenceCPIndex(newRef, tag != TagValues.CONSTANT_Fieldref);
                    if (cpIndex == -1) {
                        cpIndex = oracle.addReferenceInfoInCP(ref, tag != TagValues.CONSTANT_Fieldref);
                    } else  if (pOne.getMayBeDuplicate(index, tag)) {*/
                        ref.setIndex(classIndex);
                    //}
                }
            }
        //pOne.setMayBeDuplicate(cpIndex, tag, false);
        }
    }

    /**
     * ClassIndex in a ReferenceInfo may not points to a right class files
     * The class file with actual field/method might be a superclass of the 
     * given index.
     * The object of this function is the change the index to a (super) class
     * where field/method actually exist. Otherwise, if it cannot find that class
     * and reach Object class then it exit program. 
     * 
     * @param refInfo
     * @param tag
     * @param cFile
     * @return
     */
    private int getReferenceInfoClassIndex(ReferenceInfo refInfo, int tag,
            ClassFile cFile) {

        if (oracle.isReferenceFromClassFile(refInfo, cFile, tag != TagValues.CONSTANT_Fieldref)) {
            return cFile.getThisClass().intValueUnsigned();
        }
        int superClass = cFile.getSuperClass().intValueUnsigned();
        if (superClass != 0) {
            ClassFile sClassFile = oracle.getClass(superClass, pOne);
            if (sClassFile != null) { //loaded
                return getReferenceInfoClassIndex(refInfo, tag, sClassFile);
            } else {
                return -1;
            }
        }

        if (false) {
            Miscellaneous.printlnErr("Error in function fixReferenceInfoClassIndex  -- " + refInfo);
            new Exception().printStackTrace();
            Miscellaneous.exit();
        }
        return -1;
    }

    private void gloalizeSuperPointer(ClassFile cfile) throws Exception {
        if (cfile.getSuperClass().intValueUnsigned() != 0) { //remember Object has no super class.
            cfile.setSuperClass(pOne.getGlobalIndexUn(
                    cfile.getSuperClass(), ClassFile.currentClassToWorkOn,
                    TagValues.CONSTANT_Class));
        }
    }

    private void gloalizeThisPointer(ClassFile cfile) throws Exception {
        cfile.setThisClass(pOne.getGlobalIndexUn(cfile.getThisClass(),
                cfile, TagValues.CONSTANT_Class));
    }

    /**
     * The function will change local FieldInfo, MethodInfo objects to Global Objects
     * @param localVector Vector
     * @throws Exception
     */
    private void globalizeFieldMethodInfo(ControllerBase cntrl) throws
            Exception {
        if (cntrl == null) {
            return; //no methods or fields we have
        }

        FieldInfo fInfo = null;
        int size = cntrl.getCurrentSize();
        for (int loop = 0; loop < size; loop++) {
            fInfo = (FieldInfo) cntrl.get(loop);
//            Miscellaneous.println(fInfo.getNameIndex());
            fInfo.setNameIndex(pOne.getGlobalIndexUn(fInfo.getNameIndex(),
                    ClassFile.currentClassToWorkOn, TagValues.CONSTANT_Utf8));
            fInfo.setDescriptorIndex(pOne.getGlobalIndexUn(fInfo.getDescriptorIndex(),
                    ClassFile.currentClassToWorkOn, TagValues.CONSTANT_Utf8));
/*            fInfo.setThisClass(pOne.getGlobalIndexUn(fInfo.getThisClass(),
                    ClassFile.currentClassToWorkOn, TagValues.CONSTANT_Class));
 * 
 */
        }
    }

    /**
     * The function will change local ReferenceInfo objects to Global Object
     * That means making MethodRefInfo, FieldRefInfo and InterfaceRefInfo to global objects
     * @param localVector Vector
     * @throws Exception
     */
    private void globalizeReferenceInfo(int tag) throws
            Exception {
        //Miscellaneous.println(cp.oldtoString());
        ReferenceInfo rBase = null;
        String key = null;
        for (int loop = 0; loop < pOne.getCurrentSize(tag); loop++) {
            if (pOne.get(loop, tag) instanceof EmptyInfo) {
                continue;
            }
            ClassFile.currentClassToWorkOn = pOne.getClass(loop, tag);
            rBase = (ReferenceInfo) pOne.get(loop, tag);
            rBase.setIndex(pOne.getGlobalIndexUn(rBase.getIndex(),
                    ClassFile.currentClassToWorkOn,
                    TagValues.CONSTANT_Class));
            rBase.setNameAndType(pOne.getGlobalIndexUn(
                    rBase.getNameAndTypeIndex(),
                    ClassFile.currentClassToWorkOn,
                    TagValues.CONSTANT_NameAndType));
        }
    }
}
