/*
 * Copyright 2010 Christian Schindelhauer, Peter Thiemann, Faisal Aslam, Luminous Fennell and Gidon Ernst.
 * All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 * 
 * This code is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3
 * only, as published by the Free Software Foundation.
 * 
 * This code is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 3 for more details (a copy is
 * included in the LICENSE file that accompanied this code).
 * 
 * You should have received a copy of the GNU General Public License
 * version 3 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 * 
 * Please contact Faisal Aslam 
 * (aslam AT informatik.uni-freibug.de or studentresearcher AT gmail.com)
 * if you need additional information or have any questions.
 */
package takatuka.optimizer.deadCodeRemoval.logic;

import takatuka.classreader.dataObjs.attribute.*;
import takatuka.classreader.logic.*;
import takatuka.classreader.logic.logAndStats.*;
import takatuka.classreader.logic.factory.*;
import takatuka.optimizer.deadCodeRemoval.logic.cp.*;
import takatuka.optimizer.deadCodeRemoval.logic.factory.*;
import takatuka.optimizer.cpGlobalization.logic.util.*;
import takatuka.optimizer.deadCodeRemoval.logic.fields.*;
import takatuka.optimizer.deadCodeRemoval.logic.classAndMethod.*;
import takatuka.vm.autoGenerated.forExceptionPrettyPrint.*;

/**
 * 
 * Description:
 * <p>
 *
 * </p> 
 * @author Faisal Aslam, Christoph Gonsior, Sebastian Wagner, Natascha Widder
 * @version 1.0
 */
public class StartMeDCR extends StartMeClassReader {

    private static boolean shouldWork = true;
    public static final String DEAD_CODE_REMOVAL_FILE = "dead_code_removal_log.txt";
    private LogHolder logHolder = LogHolder.getInstanceOf();
    private static MAndCRemovalAlgo mcAlgo = MAndCRemovalAlgo.getInstanceOf();

    @Override
    public void setFactoryFacade() {
        super.setFactoryFacade();
        FactoryPlaceholder.getInstanceOf().setFactory(DCFactoryFacade.getInstanceOf());
    }

    /**
     * @param value
     * if true then the dead-code removal will work. By default it is true.
     */
    public static void setShouldWork(boolean value) {
        shouldWork = value;
    }

    @Override
    public void execute(String args[]) throws Exception {
        super.execute(args);
        if (shouldWork) {
            mcAlgo.execute();
            DeadFieldRemover.getInstanceOf().execute();
        }
        if (true) {
            logHolder.addLog("Started CP entries removal ");
            CPReferrenceFromBytecodeCounter.getInstanceOf().mark();
            logHolder.addLog("CP entries marked");
            DCRFromCP.getInstanceOf().execute();
            logHolder.addLog("End removing non-used CP entries");
        }
        postDeadCodeRemovalTasks();
        LineNumberController.getInstanceOf().storeLineNumbers();
    }

    private void postDeadCodeRemovalTasks() {
        BytecodeProcessor.refreshOpcodeUsedOriginally();
        Oracle oracle = Oracle.getInstanceOf();
        CodeAtt.setCodeTotalengthInput(oracle.getCurrentTotalCodeLength());
        oracle.clearMethodCodeAttAndClassFileCache();
    }

    public static void setMainClassName(String fullyQualifiedMainClassName) {
        mcAlgo.setMainClassName(fullyQualifiedMainClassName);
    }

    public static String getMainClassName() {
        return mcAlgo.getMainClassName();
    }

    public static void main(String args[]) throws Exception {
        (new StartMeDCR()).start(args);
    }
}
