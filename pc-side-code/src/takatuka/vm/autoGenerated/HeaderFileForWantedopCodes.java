/*
 * Copyright 2010 Christian Schindelhauer, Peter Thiemann, Faisal Aslam, Luminous Fennell and Gidon Ernst.
 * All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 * 
 * This code is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3
 * only, as published by the Free Software Foundation.
 * 
 * This code is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 3 for more details (a copy is
 * included in the LICENSE file that accompanied this code).
 * 
 * You should have received a copy of the GNU General Public License
 * version 3 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 * 
 * Please contact Faisal Aslam 
 * (aslam AT informatik.uni-freibug.de or studentresearcher AT gmail.com)
 * if you need additional information or have any questions.
 */
package takatuka.vm.autoGenerated;

import java.util.*;
import java.io.*;
import takatuka.classreader.dataObjs.attribute.*;
import takatuka.classreader.logic.file.*;
import takatuka.classreader.logic.util.*;
import takatuka.optimizer.bytecode.changer.logic.InputOptionsController;

/**
 * 
 * Description:
 * <p>
 * 
 * It generates a header file for wanted bytecode.
 * 
 * </p> 
 * @author Faisal Aslam
 * @version 1.0
 */
public class HeaderFileForWantedopCodes {

    private static final Properties prop = PropertyReader.getInstanceOf().
            getProperties(ConfigPropertyReader.CONFIG_PROPERTY);
    private static final String PROP_NAME = "WANTED_OP_CODES_HEADER";
    private static final String HEADER_FILE_NAME_AND_PATH =
            prop.getProperty(PROP_NAME);
    private static final String PRE_STRING = "#define WANT_OP_";
    private static final String NOT_IMPLEMENTED_OPCODES = "not-implemented-opcode-mnemonic.properties";
    private static final String OPNEM = "opcode-mnemonic.properties";
    private static final Properties opcodeMnemoicProperties = PropertyReader.getInstanceOf().loadProperties(OPNEM);
    private static final Properties notImpmentedOpcodesMnemonics = PropertyReader.getInstanceOf().loadProperties(NOT_IMPLEMENTED_OPCODES);
    private static final HeaderFileForWantedopCodes headerWantedOpCode =
            new HeaderFileForWantedopCodes();
    private static final String GENERAL_JVM_OPCODES="opcodes-general-jvm.properties";

    private String getMnemonic(int opCode) {
        return opcodeMnemoicProperties.getProperty(
                opCode + "").trim();
    }

    public static HeaderFileForWantedopCodes getInstanceOf() {
        return headerWantedOpCode;
    }

    public static TreeSet<Integer> generalPurposeJVMOpcodes() {
        TreeSet<Integer> ret = new TreeSet();
        if (InputOptionsController.isGPJVMWanted()) {
            Set temp =  PropertyReader.getInstanceOf().loadProperties(GENERAL_JVM_OPCODES).keySet();
            for (Object key: temp) {
                ret.add(Integer.parseInt((String)key));
            }
        }
        return ret;
    }

    private void remove (TreeSet<Integer> source, TreeSet<Integer> toRemove) {
        source.removeAll(toRemove);
/*        Iterator<Integer> srcIt = source.iterator();
        while (srcIt.hasNext()) {
            Integer src = srcIt.next();
            
        }*/
    }
    /**
     * This is from where we start ...
     */
    public void execute() {
        try {
            TreeSet<Integer> unUsedInst = BytecodeProcessor.getUnUsedOpCodes();
            TreeSet<Integer> allGPJVMOpcodes = generalPurposeJVMOpcodes();
            unUsedInst.removeAll(allGPJVMOpcodes);
                        
            StringBuffer bigString =
                    new StringBuffer(HeaderFileConstants.headerStart(HEADER_FILE_NAME_AND_PATH));
            for (int loop = 0; loop < 256; loop++) {
                if (!unUsedInst.contains(loop)) {
                    bigString.append(PRE_STRING + getMnemonic(loop).toUpperCase() + "\n");
                }
            }
            bigString.append(HeaderFileConstants.headerEnd());
            ClassFileWriter.writeFile(new File(HEADER_FILE_NAME_AND_PATH),
                    bigString.toString());

        } catch (Exception d) {
            d.printStackTrace();
            Miscellaneous.exit();
        }
    }
}
