/*
 * Copyright 2010 Christian Schindelhauer, Peter Thiemann, Faisal Aslam, Luminous Fennell and Gidon Ernst.
 * All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 * 
 * This code is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3
 * only, as published by the Free Software Foundation.
 * 
 * This code is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 3 for more details (a copy is
 * included in the LICENSE file that accompanied this code).
 * 
 * You should have received a copy of the GNU General Public License
 * version 3 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 * 
 * Please contact Faisal Aslam 
 * (aslam AT informatik.uni-freibug.de or studentresearcher AT gmail.com)
 * if you need additional information or have any questions.
 */
package takatuka.vm.autoGenerated;

import takatuka.chunkSizeCalc.GenerateCVCSInfo;
import java.io.*;
import takatuka.classreader.logic.constants.*;
import takatuka.classreader.logic.file.*;
import takatuka.tukFormat.dataObjs.*;
import takatuka.tukFormat.logic.*;
import takatuka.optimizer.cpGlobalization.dataObjs.constantPool.GCP.*;
import takatuka.optimizer.cpGlobalization.logic.util.*;
import takatuka.optimizer.deadCodeRemoval.dataObj.*;
import takatuka.optimizer.deadCodeRemoval.logic.*;
import takatuka.classreader.logic.util.*;
import java.util.*;
import takatuka.classreader.dataObjs.constantPool.*;
import takatuka.offlineGC.generateInstrs.*;
import takatuka.vm.autoGenerated.forExceptionPrettyPrint.GenerateExceptionData;
import takatuka.vm.autoGenerated.tables.*;

/**
 * 
 * Description:
 * <p>
 * </p> 
 * @author Faisal Aslam
 * @version 1.0
 */
public class JVMConfiguration {

    private static final String JVM_CONFIG = "JVM_CONFIG";
    private static final ConfigPropertyReader cPropReader =
            ConfigPropertyReader.getInstanceOf();
    private static final JVMConfiguration misc = new JVMConfiguration();
    private static final String U1_CLASS = "Java_takatuka_vm_types_U1Array_classId";
    private static final String U2_CLASS = "Java_takatuka_vm_types_U2Array_classId";
    private static final String U4_CLASS = "Java_takatuka_vm_types_U4Array_classId";
    private static final String U8_CLASS = "Java_takatuka_vm_types_U8Array_classId";
    private static final String REF_CLASS = "Java_takatuka_vm_types_ReferenceArray_classId";
    private static final String SPACE = " ";
    private static final String DEFINE = "\n#define";
    private static final String MAIN_METHOD_ID = "MAIN_METHOD_ID";
    private static final String MAIN_METHOD_NAME = "main";
    private static final String MAIN_METHOD_DESC = "([Ljava/lang/String;)V";
    private static final String SIZE_OF_STATIC_FIELDS = "SIZE_OF_STATIC_FIELDS";
    private static final String NUMBER_OF_CLASSES_DEFINE = "NUMBER_OF_CLASS_FILES";
    private static final String SIZE_FOR_CVCS_DEFINE = "SIZE_OF_CVCS";
    private static final String NUMBER_OF_INTERFACES_DEFINE = "NUMBER_OF_INTERFACES";
    private static final String COMPILE_UNIX_TIMESTAMP = "COMPILE_UNIX_TIMESTAMP";
    private static final String TOTAL_NEW_INSTRUCTION_ID = "TOTAL_NUMBER_OF_NEW_AND_LDC_INSTRS_USED_BY_OFFLINE_GC";
    private static final String INTERFACE_MAX_DEPTH = "MAX_DEPTH_INTERFACES";
    private static final String ADDRESS_LENGTH = "address_length";
    private static final String VM_INIT_METHOD_NAME = "takatuka.vm.VM.initialize()V";
    private static final String CONFIG_VM_INIT_METHOD = "VM_INIT_METHOD_ID";
    
    private int numberOfClassFiles = 0;
    private int numberOfInterfaces = 0;
    private int numberOfClassFilesForArrays = 0;
    public static int maxNewIdGenerated = -1;

    private JVMConfiguration() {
    }

    public static JVMConfiguration getInstanceOf() {
        return misc;
    }

    /**
     * start from the end.
     * 1. first will find classfiles with arrays.
     * 2. second will find interfaces.
     * 3. rest will be normal classes.
     */
    private void calculateNumberOfClassFiles() {
        GlobalConstantPool gcp = GlobalConstantPool.getInstanceOf();
        int size = gcp.getCurrentSize(TagValues.CONSTANT_Class);
        numberOfClassFiles = 0;
        numberOfClassFilesForArrays = 0;
        numberOfInterfaces = 0;
        for (int loop = size - 1; loop > 0; loop--) {
            ClassInfo info = (ClassInfo) gcp.get(loop, TagValues.CONSTANT_Class);
            if (info.getIsInterface()) {
                numberOfInterfaces++;
            } else if (info.getClassName().trim().startsWith("[")) {
                numberOfClassFilesForArrays++;
            } else {
                numberOfClassFiles = size - numberOfInterfaces - numberOfClassFilesForArrays;
            }
        }
    }

    public void updateJVMConfig(int addressLength) throws Exception {
        GenerateCVCSInfo cvcsInfo = new GenerateCVCSInfo();
        cvcsInfo.execute();
        calculateNumberOfClassFiles();
        String jvmConfigFile = cPropReader.getConfigProperty(JVM_CONFIG);
        String write = HeaderFileConstants.headerStart(jvmConfigFile);
        write += addDefine(ADDRESS_LENGTH, addressLength);
        
        write += addDefine(NUMBER_OF_CLASSES_DEFINE, numberOfClassFiles);

        write += addDefine(NUMBER_OF_INTERFACES_DEFINE, numberOfInterfaces);

        if (maxNewIdGenerated == -1) {
            write += addDefine(TOTAL_NEW_INSTRUCTION_ID,
                    GenerateInstrsForOfflineGC.getInstanceOf().maxNewIdGenerated());
        } else {
            write += addDefine(TOTAL_NEW_INSTRUCTION_ID, maxNewIdGenerated);
        }
        
        write += addClassIDs();

        write += addMainClassId();

        write += addSizeOfAllStatics();

        write += addDefine(SIZE_FOR_CVCS_DEFINE,
                cvcsInfo.getBytesToStoreCVSEntries());
        write += addDefine(CONFIG_VM_INIT_METHOD, 
                GenerateExceptionData.getInstanceOf()
                .getMethodID(VM_INIT_METHOD_NAME));
        write += addInterfaceDepth();
        //From Karl
        write += addUnixTimeStamp();
        //End of From Karl


        write += HeaderFileConstants.headerEnd();

        if (jvmConfigFile == null) {
            Miscellaneous.printlnErr("ERROR: Cannot find JVM_CONFIG"
                    + " Property in config.properties");
            Miscellaneous.exit();
        }
        ClassFileWriter.writeFile(new File(jvmConfigFile), write);
        
    }

    private String addInterfaceDepth() {
        InterfacesMaxDepth interMaxDepth = InterfacesMaxDepth.getInstanceOf();
        int maxDepth = interMaxDepth.getMaxDepthOfInterfaces();
        return addDefine(INTERFACE_MAX_DEPTH, maxDepth);
    }

    private String addDefine(String toDefine, Object value) {
        return DEFINE + SPACE + toDefine + SPACE + value;
    }

    private String addClassIDs() {
        String str = "";
        Vector<String> missingPrimativeTypes = ArrayClassesMap.getInstanceOf().execute();
        int maxClassId = GlobalConstantPool.getInstanceOf().
                getCurrentSize(TagValues.CONSTANT_Class);
        for (int loop = 0; loop < missingPrimativeTypes.size(); loop++) {
            String primType = missingPrimativeTypes.elementAt(loop);
            //Miscellaneous.println("------------ see me 1"+primType);
            String longName = ReferenceTableEntryCreator.createName(primType, null, null);
            //Miscellaneous.println("------------ see me 2"+longName);
            str += addDefine(longName + "_classId", maxClassId++);
        }
        str += addDefine(REF_CLASS, maxClassId++);

        return str;
    }

    private String addMainClassId() {
        Oracle oracle = Oracle.getInstanceOf();
        String mainClassName = StartMeDCR.getMainClassName();
        if (mainClassName == null) {
            return "";
        }
        LFClassFile cFile = (LFClassFile) oracle.getClass(mainClassName);
        if (cFile == null) {
            Miscellaneous.printlnErr("ERROR: Cannot find main class file " + mainClassName + ". May be your "
                    + "package name is not in right case or has some spelling errors");
            new Exception().printStackTrace();
            Miscellaneous.exit();
        }
        return addDefine(MAIN_METHOD_ID, getMainMethodIndex(cFile));
    }

    private int getMainMethodIndex(DCClassFile mainClassFile) {
        Oracle oracle = Oracle.getInstanceOf();
        LFMethodInfo method = (LFMethodInfo) oracle.getMethodOrField(mainClassFile,
                MAIN_METHOD_NAME, MAIN_METHOD_DESC, true);
        if (method == null) {
            Miscellaneous.printlnErr("Cannot find the main method in class=" + mainClassFile.getFullyQualifiedClassName());
            new Exception().printStackTrace();
            Miscellaneous.exit();
        }
        return method.getReferenceIndex();
    }

    private String addSizeOfAllStatics() {
        return addDefine(SIZE_OF_STATIC_FIELDS, LFEngine.getInstanceOf().getStaticSize());
    }

    private String addUnixTimeStamp() {
        return addDefine(COMPILE_UNIX_TIMESTAMP, Long.toString(System.currentTimeMillis()) + "LL");
    }
}
