/*
 * Copyright 2010 Christian Schindelhauer, Peter Thiemann, Faisal Aslam, Luminous Fennell and Gidon Ernst.
 * All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 * 
 * This code is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3
 * only, as published by the Free Software Foundation.
 * 
 * This code is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 3 for more details (a copy is
 * included in the LICENSE file that accompanied this code).
 * 
 * You should have received a copy of the GNU General Public License
 * version 3 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 * 
 * Please contact Faisal Aslam 
 * (aslam AT informatik.uni-freibug.de or studentresearcher AT gmail.com)
 * if you need additional information or have any questions.
 */
package takatuka.vm.autoGenerated.vmSwitch;

import java.io.*;
import java.util.*;
import takatuka.classreader.dataObjs.attribute.*;
import takatuka.classreader.logic.file.*;
import takatuka.classreader.logic.logAndStats.*;
import takatuka.optimizer.cpGlobalization.logic.util.*;
import takatuka.vm.autoGenerated.*;
import takatuka.classreader.logic.util.*;

/**
 * 
 * Description:
 * <p>
 *
 * </p> 
 * @author Elmar Haussmann
 * @version 1.0
 */
public class GenerateLabels {

    private static final String SWITCH_HEADER = "switch(instruction) {\n";
    private static final String SWITCH_TRAIL = "\n    default: die(\"invalid bytecode\");\n}\n";
    private static final String JVM_LABELS_FILE = "JVM_LABELS_FILE";
    private static final String JVM_LABELS_MAP = "JVM_LABELS_MAP";
    public static final String CODE_START = "\n\t";
    private static final String DEFINE = "#define ";
    private static final String JVM_OPCODE_DEFINATIONS = "JVM_OPCODE_DEFINATIONS";
    private Map<Integer, OpCodeAndCode> bytecodeDefMapFromFile =
            BytecodeDefinationsReader.getInstanceOf().readFromFile();
    private HashMap<Integer, OpCodeAndCode> newInstbytecodeDefMap = new HashMap();
    private final static GenerateLabels switchGen = new GenerateLabels();
    private final static String bytecodeDefinationFile =
            ConfigPropertyReader.getInstanceOf().getConfigProperty(JVM_OPCODE_DEFINATIONS);
    private String labelsOutPutFile = ConfigPropertyReader.getInstanceOf().getConfigProperty(JVM_LABELS_FILE);
    private String labelsMapOutPutFile = ConfigPropertyReader.getInstanceOf().getConfigProperty(JVM_LABELS_MAP);
    private HashSet<OpcodeMnemonicInUse> mnemonicSet = null;
    private HashSet<OpcodeMnemonicInUse> mnemonicNotGenerated = null;
    private int usedOpcodesCount = 0;
    private String opcodeDefinationLines = "";
    private TreeSet<Integer> alreadyGeneratedCases = new TreeSet();
    private TreeSet allCases = new TreeSet();

    private GenerateLabels() {
    }

    public static GenerateLabels getInstanceOf() {
        return switchGen;
    }

    public void generate() {
        Oracle oracle = Oracle.getInstanceOf();
        try {
            mnemonicSet = GenerateSwitch.getInstanceOf().getAllOpcodeMnemonicsUseInCode();
            mnemonicNotGenerated = (HashSet) mnemonicSet.clone();
            generateCasesForSingleInst();
            generateCasesForMultInst();
            generateCasesForNonCustomizeInst();

            String labelStr = HeaderFileConstants.AUTO_GENERATED_MSG;//
            String labelMapStr = HeaderFileConstants.AUTO_GENERATED_MSG;//
            Iterator<LabelCase> cases = allCases.iterator();
            LabelCase sCase = null;
            int caseOpcode = -1;
            int maxOpCode = 0;
            HashMap<Integer, String> opCodeToLabel = new HashMap<Integer, String>();
            while (cases.hasNext()) {
                LabelCase s = cases.next();
                opCodeToLabel.put(new Integer(s.opCode), s.label);
                if (s.opCode > maxOpCode) {
                    maxOpCode = s.opCode;
                }
            }

            labelMapStr += "{\n";
            for (int i = 0; i <= maxOpCode; i++) {
                if (opCodeToLabel.get(i) != null) {
                    labelMapStr += "&&" + opCodeToLabel.get(i);
                } else {
                    labelMapStr += "&&L_DEFAULT";
                }
                if (i != maxOpCode) {
                    labelMapStr += ",";
                }
                labelMapStr += " //" + i + "\n";
            }
            labelMapStr += "};\n";
            cases = allCases.iterator();
            while (cases.hasNext()) {
                sCase = cases.next();
                /*caseOpcode ++;
                while (caseOpcode != sCase.opCode) {
                switchStr += new SwitchCase(caseOpcode, caseOpcode+"", 0, "//empty");
                caseOpcode++;
                }*/
                labelStr += sCase;
                caseOpcode = sCase.opCode;
            }
            //switchStr = switchStr + SWITCH_TRAIL+"\n L_END:\n";
            labelStr += "\n L_DEFAULT: die(ERROR_EXIT);\n";
            labelStr = labelStr + "\n L_END:\n";
            String bytecodeDefinationData = createBytecodeDefinationFile();
            ClassFileWriter.writeFile(new File(labelsOutPutFile), labelStr);
            ClassFileWriter.writeFile(new File(labelsMapOutPutFile), labelMapStr);
            ClassFileWriter.writeFile(new File(bytecodeDefinationFile),
                    bytecodeDefinationData);
            if (GenerateSwitch.getInstanceOf().getAllOpcodeMnemonicsUseInCode().size() != usedOpcodesCount) {
                Miscellaneous.printlnErr("Error #144 ");
                Miscellaneous.exit();
            }
            LogHolder.getInstanceOf().addLog("Total used opcodes (original and generated) by the program= "
                    + usedOpcodesCount + "...");
            //Miscellaneous.println("here bady here " + alreadyGeneratedCases);
        } catch (Exception d) {
            d.printStackTrace();
            Miscellaneous.exit();
        }
    }

    private void generateCasesForNonCustomizeInst() {
        String mnemonic = null;
        Iterator<OpcodeMnemonicInUse> it = ((HashSet) mnemonicNotGenerated.clone()).iterator();
        int opCode = -1;
        OpCodeAndCode opcodeAndCode = null;//1
        while (it.hasNext()) {

            mnemonic = it.next().mnemonic;
            opCode = Instruction.getOpcode(mnemonic);
            if (opCode == -1) {
                Miscellaneous.printlnErr("Error # 101: Cannot find opcode for " + mnemonic);
                Instruction.getOpcode(mnemonic);
                Miscellaneous.exit();
            }

            opcodeAndCode = bytecodeDefMapFromFile.get(opCode);
            createCase(opCode, opcodeAndCode.codeWithDefaultAgument,
                    BytecodeProcessor.getTotalParameterSize(opCode) + 1, mnemonic);
        }
    }

    private void generateCasesForSingleInst() {
        RegisterCustomInstruction regCustomInst = RegisterCustomInstruction.getInstanceOf();

        HashMap<Integer, SingleInstrOptimRecord> newInstrToSingleOldInstMap = regCustomInst.newInstrToSingleOldInstMap;

        Set keys = newInstrToSingleOldInstMap.keySet();
        SingleInstrOptimRecord singInstRec = null;
        Iterator<Integer> it = keys.iterator();
        int opcode = -1;
        OpCodeAndCode opcodeAndcode = null;
        while (it.hasNext()) {
            opcode = it.next();
            singInstRec = newInstrToSingleOldInstMap.get(opcode);
            opcodeAndcode = bytecodeDefMapFromFile.get(singInstRec.oldOpCode);
            if (opcodeAndcode.code.contains("fun_castw(@@1 @@2)")) {
             //   Miscellaneous.println("here there 12");
            }
            if (opcodeAndcode == null) {
                Miscellaneous.printlnErr("Invalid bytecode defination file. Missing opcode= " + singInstRec.oldOpCode);
                Miscellaneous.exit();
            }
            OpCodeAndCode newOcAc = new OpCodeAndCode();
            //todo write clone function
            newOcAc.code = opcodeAndcode.code;
            newOcAc.argumentFunction = opcodeAndcode.argumentFunction;
            newOcAc.argumentType = opcodeAndcode.argumentType;
            newOcAc.opCode = singInstRec.newInstruction.getOpCode();
            //-------
            GenerateSwitch.updateMap(newInstbytecodeDefMap, newOcAc,
                    singInstRec.operandSize, singInstRec.fixOperand,
                    BytecodeProcessor.getAllParameterSizes(singInstRec.oldOpCode));
            createCase(singInstRec.newInstruction.getOpCode(), newOcAc.code,
                    singInstRec.operandSize + 1, singInstRec.newInstruction.getMnemonic());
        }
    }

    private void generateCasesForMultInst() {
        RegisterCustomInstruction regCustomInst = RegisterCustomInstruction.getInstanceOf();
        HashMap<Integer, MultiInstrOptimRecord> newInstrToOldInstsMap =
                regCustomInst.newInstrToOldInstsMap;
        Set keys = newInstrToOldInstsMap.keySet();
        Iterator it = keys.iterator();
        Integer opcodeKey = null;
        MultiInstrOptimRecord mInstRec = null;
        int oldOpCode = -1;
        int length = 0;
        String code = null;
        String aggregatedCode = "";
        String mnemonic = "";
        while (it.hasNext()) {
            opcodeKey = (Integer) it.next();
            mInstRec = newInstrToOldInstsMap.get(opcodeKey);
            aggregatedCode = CODE_START;
            int size = mInstRec.oldOpCodes.size();
            length = mInstRec.newInstruction.length();
            mnemonic = mInstRec.newInstruction.getMnemonic();
            for (int loop = 0; loop < size; loop++) {
                //get code----
                oldOpCode = mInstRec.oldOpCodes.elementAt(loop);
                code = newInstbytecodeDefMap.get(oldOpCode) != null ? newInstbytecodeDefMap.get(oldOpCode).code : "";
                //---
                //its is a usual bytecode instruction instead of a custom instruction
                if (code.length() == 0) {
                    code = bytecodeDefMapFromFile.get(oldOpCode).codeWithDefaultAgument;
                }
                if (code.length() == 0) {
                    Miscellaneous.printlnErr(" Cannot find instruction"
                            + " for generating VM switch");
                }
                aggregatedCode = aggregatedCode + code + CODE_START;
            }
            createCase(opcodeKey, aggregatedCode, length, mnemonic);
        }
    }

    private void createCase(int opCode, String aggregatedCode,
            int instLength, String newMnemonic) {
        OpcodeMnemonicInUse temp = new OpcodeMnemonicInUse(newMnemonic, opCode);
        if (!mnemonicSet.contains(temp)) {
            return;
        }
        mnemonicNotGenerated.remove(temp);
        usedOpcodesCount++;
        LabelCase labelCase = new LabelCase(opCode, newMnemonic, instLength, aggregatedCode);
        allCases.add(labelCase);
        if (alreadyGeneratedCases.contains(opCode)) {
            new Exception(opCode + "").printStackTrace();
            Miscellaneous.exit();
        }
        alreadyGeneratedCases.add(opCode);
        createBytecodeDefinationLine(newMnemonic, opCode);
    }

    private void createBytecodeDefinationLine(String mnemonic, int opcode) {
        opcodeDefinationLines += "\n" + DEFINE + " " + mnemonic + " " + opcode;
    }

    private String createBytecodeDefinationFile() {
        String ret = HeaderFileConstants.headerStart(bytecodeDefinationFile);
        ret = ret + opcodeDefinationLines;
        ret = ret + "\n\n" + HeaderFileConstants.headerEnd();
        return ret;
    }
}
